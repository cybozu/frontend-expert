{"pageProps":{"post":{"slug":"vite-3.0","content":"<p>2022/7/13に、フロントエンドツールである Vite のバージョン 3.0 がリリースされました 🎉</p>\n<ul>\n<li><a href=\"https://vitejs.dev/blog/announcing-vite3.html\">Vite 3.0 is out! | Vite</a></li>\n<li><a href=\"https://github.com/vitejs/vite/blob/v3.0.0/packages/vite/CHANGELOG.md\">CHANGELOG</a></li>\n<li><a href=\"https://vitejs.dev/guide/migration.html\">Migration from v2 | Vite</a></li>\n</ul>\n<p>このエントリーでは、リリース時に公開されたアナウンス(<a href=\"https://github.com/vitejs/vite/releases/tag/v3.0.0\">Release v3.0.0 · vitejs/vite</a>)の内容をベースに、変更点を改めて１つずつ掘り下げて確認してみます。</p>\n<h3>New Documentation</h3>\n<p>公式ドキュメント(<a href=\"https://ja.vitejs.dev/\">vitejs.dev</a>)が <a href=\"https://vitepress.vuejs.org/\">VitePress</a> のデフォルトテーマを利用した形で刷新されました。ダークテーマ表示などが可能になっています。</p>\n<p>また、あわせて次のサブドメインでもドキュメントを閲覧できるようになっています。</p>\n<ul>\n<li><a href=\"https://v2.vitejs.dev/\">v2.vitejs.dev</a> - Vite 2.x 系のドキュメント</li>\n<li><a href=\"https://main.vitejs.dev/\">main.vitejs.dev</a> - Vite のメインブランチの内容</li>\n</ul>\n<h3>Create Vite Starter Templates</h3>\n<p>Vite プロジェクトの Scaffold ジェネレータである <a href=\"https://github.com/vitejs/vite/tree/main/packages/create-vite\"><code>create-vite</code></a> について、Vite 3.x が利用されるようになりました。</p>\n<h3>Dev Improvements</h3>\n<h4>Vite CLI</h4>\n<p>デフォルトの開発サーバーポートが <code>5173</code>、プレビューサーバーのポートが <code>4173</code> に変更されました。デフォルトポートは以前は <code>3000</code> と <code>5000</code> でしたが、MacOS でポートの衝突が発生するなどの<a href=\"https://github.com/vitejs/vite/issues/5707\">問題があった</a>ようです。</p>\n<p>ちなみになぜ <code>5173</code> という中途半端な数字なのだろう？と思い調べてみましたが、以下の Issue コメントを見つけました。</p>\n<p><a href=\"https://github.com/vitejs/vite/pull/6330#issuecomment-1003405068\">https://github.com/vitejs/vite/pull/6330#issuecomment-1003405068</a></p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">At a team meeting we thought about 5173\nLike 5173 in leet for Vite | V I T Ǝ | V === Roman 5</code></pre></div>\n<ul>\n<li>V … 5</li>\n<li>I … 1</li>\n<li>T … 7</li>\n<li>Ǝ … 3</li>\n</ul>\n<p>らしいです。cool</p>\n<h4>Improved WebSocket Connection Strategy</h4>\n<p>Vite 2.x までは、Proxy を経由したサーバー確立に課題があったとのことで、3.0 からはそれが改善されました。</p>\n<p><a href=\"https://github.com/sapphi-red/vite-setup-catalogue\"><code>vite-setup-catalogue</code></a> というセットアップのサンプルリポジトリ内にも追加されたことで、今後は同パターンは CI で検証されるようになったとのことです。</p>\n<h4>Cold Start Improvements</h4>\n<p>コールドスタート時に依存関係を後から解決する際に、依存の状態によってはフルリロードが発生する可能性があったのが、ブラウザに依存を渡すタイミングを調整することで効率化され、回避可能になったようです。</p>\n<p>詳細: <a href=\"https://github.com/vitejs/vite/pull/8869#issuecomment-1172902125\">https://github.com/vitejs/vite/pull/8869#issuecomment-1172902125</a></p>\n<h4>import.meta.glob</h4>\n<p>Vite では以前から <a href=\"https://vitejs.dev/guide/features.html#glob-import\"><code>Glob Import</code></a> と呼ばれる機能が存在し、特別な関数 <code>import.meta.glob</code> を介して glob 形式で記述してのモジュール一括インポートが可能です。</p>\n<p>Vite 3.0 では機能が強化され、より柔軟な指定が可能になりました。</p>\n<ul>\n<li>Multiple Patterns : 複数の glob パターンの記述</li>\n<li>Negative Patterns : 除外パターンの記述</li>\n<li>Named Imports : モジュールの一部のみを指定可能</li>\n<li>Custom Queries : クエリの付与</li>\n<li>Eager Imports : Dynamic import の回避</li>\n</ul>\n<h4>Aligning WASM Import with Future Standards</h4>\n<p>Vite 2.x から WebAssembly を</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword module\">import</span> <span class=\"token imports\">init</span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'./example.wasm'</span>\n</code></pre></div>\n<p>の形で import できましたが、将来的に ESM の仕様として WebAssembly が統合された場合のバッティングを考慮し、</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword module\">import</span> <span class=\"token imports\">init</span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'./example.wasm?init'</span>\n</code></pre></div>\n<p>と、<code>?init</code> オプションが付与された場合に Vite 2.x 以前と同様の挙動になるよう変更されました。</p>\n<p>現状で <code>?init</code> オプションを付与せずに ESM として処理する場合には <a href=\"https://github.com/Menci/vite-plugin-wasm\"><code>vite-plugin-wasm</code></a>のようなプラグインの利用が必須となります。</p>\n<h3>Build Improvements</h3>\n<h4>ESM SSR Build by Default</h4>\n<p>SSR 用フレームワークの大半が ESM ビルドを利用するようになったため、\nVite3 では SSR ビルドのデフォルト形式が ESM に変更されました。</p>\n<p>Vite では、モジュールの形式(CommonJS/ESM)などに応じて、適宜 Vite の変換から切り離す（外部化する）ことで SSR 時の処理を効率化しています。</p>\n<p>参考: <a href=\"https://v2.vitejs.dev/guide/ssr.html#ssr-externals\">https://v2.vitejs.dev/guide/ssr.html#ssr-externals</a></p>\n<p>ESM がデフォルトになったことで、デフォルトで外部化される依存が増え、より効率的に SSR ビルドが可能になるようです。</p>\n<p>なお、ESM になると困るケースのために <code>legacy.buildSsrCjsExternalHeuristics: true</code> というオプションも用意されているようです。</p>\n<h4>Improved Relative Base Support</h4>\n<p><code>base</code> に <code>''</code> を指定することで、相対的なベースパスの指定ができるようになりました。\nビルドの段階でベースパスが不明なケースなどで役に立つようです。</p>\n<h3>Experimental Features</h3>\n<h4>Built Asset Paths fine-grained Control (Experimental)</h4>\n<p><code>experimental.renderBuiltUrl</code> オプションが Experimental 機能として導入されました。</p>\n<p>CDN での配布などを前提とした場合、ビルドによって生成されたアセットのうち一部のみ URL が異なるケースが考えられます。</p>\n<p><code>experimental.renderBuiltUrl</code> を指定することで、ファイル名・ファイルタイプなどを利用して URL を切り分けられるようになります。</p>\n<p>※公式ドキュメントよりコードを抜粋\n<a href=\"https://vitejs.dev/guide/build.html#advanced-base-options\">https://vitejs.dev/guide/build.html#advanced-base-options</a></p>\n<div class=\"remark-highlight\"><pre class=\"language-ts\"><code class=\"language-ts\">experimental<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">renderBuiltUrl</span><span class=\"token punctuation\">(</span>filename<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> hostType<span class=\"token operator\">:</span> <span class=\"token string\">'js'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'css'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'html'</span><span class=\"token punctuation\">,</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'public'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'asset'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'public'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'https://www.domain.com/'</span> <span class=\"token operator\">+</span> filename\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">extname</span><span class=\"token punctuation\">(</span>importer<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'.js'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> runtime<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">window.__assetsPath(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'https://cdn.domain.com/assets/'</span> <span class=\"token operator\">+</span> filename\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h4>Esbuild Deps Optimization at Build Time (Experimental)</h4>\n<p><code>optimizeDeps.disabled: false</code> 指定が Experimental 機能として可能になりました。\n<a href=\"https://vitejs.dev/guide/migration.html#experimental\">https://vitejs.dev/guide/migration.html#experimental</a></p>\n<p>Vite はデフォルトでは開発時には esbuild を用い、ビルド時には Rollup を利用します。\n開発時とビルド時で異なるツールを利用するため、Vite を利用する際に考慮すべき大きい要素の一つとして挙げられます。</p>\n<p>参考: <a href=\"https://vitejs.dev/guide/why.html#why-not-bundle-with-esbuild\">Why Not Bundle with esbuild?</a></p>\n<p><code>optimizeDeps.disabled: false</code> を用いると、ビルド時にも esbuild を利用するようになります。</p>\n<p>CJS のみの依存関係も ESM に変換されるため、<code>@rollup/plugin-commonjs</code> プラグインが不要となります。</p>\n<h4>HMR Partial Accept (Experimental)</h4>\n<p><code>experimental.hmrPartialAccept</code> オプションが Experimental 機能として導入されました。</p>\n<p>Vite ではフレームワークやツールの作成者向けに HMR 用の API を公開しています。\n<a href=\"https://vitejs.dev/guide/api-hmr.html\">https://vitejs.dev/guide/api-hmr.html</a></p>\n<p>現状の HMR API の仕組みでは、HMR 可能なモジュールとそうでないモジュールが混在していたファイルの場合、\nモジュールを部分的に差し替えることができず、非効率な更新が発生する可能性があります。</p>\n<p>参考: <a href=\"https://github.com/vitejs/vite/discussions/7309\">HMR partial accept · Discussion #7309 · vitejs/vite</a></p>\n<p>新しい API である <code>import.meta.hot.acceptExports</code> と組み合わせることで、\nexport されているモジュールについてより詳細かつ効率的に HMR の制御が可能になります。</p>\n<h3>Bundle Size Reduction</h3>\n<p>Vite 自体のサイズが小さくなりました。30%ほど軽量化されたそうです。</p>\n<p>Minify 用の Terser がオプションになったことや、 <code>node-forge</code> が <code>vitejs/plugin-basic-ssl</code> というプラグインに置き換わったことに起因しているようです。</p>\n<h3>Compatibility Notes</h3>\n<ul>\n<li>Node.js のサポートバージョンが 14.18+ / 16+ になりました</li>\n<li>Vite 自体が ESM として公開されています。CJS経由で利用する場合は CJS Proxy 経由となります\n<ul>\n<li>参考: teppeis/<a href=\"https://zenn.dev/teppeis/articles/2022-07-npm-dual-pacakge-cjs-proxy\">Vite 3 が採用した CJS Proxy による Dual Package 構成</a></li>\n</ul>\n</li>\n<li>サポートブラウザの基準が <code>\"Native ESM\"</code> <code>\"Native ESM dynamic import\"</code> <code>\"import.meta\"</code> の機能をサポートしているブラウザになりました</li>\n<li>SSR および ライブラリモードにおいて、JS の拡張子はフォーマットやパッケージタイプに応じて適切な拡張子が選択されるようになりました</li>\n</ul>\n<p>ブラウザバージョンが変わった点は注意が必要になるかもしれません。\nMigration Guide によると、主要ブラウザでは次のバージョンがサポート対象になるようです。</p>\n<ul>\n<li>Chrome >=87</li>\n<li>Firefox >=78</li>\n<li>Safari >=13</li>\n<li>Edge >=88</li>\n</ul>\n<hr>\n<p>というわけで簡単な Vite 3.0 の内容のおさらいでした。</p>\n<p>Vite はもともと Native ESM を前提とした仕組みをフル活用していることもあってか、\n今回の変更点でも ESM を考慮した変更が多く入った印象を受けます。</p>\n<p>個人的には、まだ Experimental ではありますが <code>Esbuild Deps Optimization at Build Time</code> にある、\nビルド時にも esbuild を利用可能になる未来が楽しみです。</p>\n","metaData":{"title":"Vite 3.0 の内容をおさらいする","author":"mugi","createdAt":"2022-07-27","summary":"Vite 3.0 の内容をおさらいします","tags":["Vite"],"updatedAt":"2022-07-27"}}},"__N_SSG":true}