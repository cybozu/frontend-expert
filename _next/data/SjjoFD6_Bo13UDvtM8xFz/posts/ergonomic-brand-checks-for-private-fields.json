{"pageProps":{"post":{"slug":"ergonomic-brand-checks-for-private-fields","content":"<p>2021年7月に行われた TC39 ミーティングで <a href=\"https://github.com/tc39/proposal-private-fields-in-in\">Ergonomic brand checks for Private Fields</a> というプロポーザルが Stage 4 になりました。\nこのプロポーザルは、ES2022 に含まれる予定です。また、<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-rc/#private-field-presence-checks\">TypeScript 4.5 にも含まれる予定です</a>。</p>\n<p>この記事では、Ergonomic brand checks for Private Fields について解説します。</p>\n<h2>概要</h2>\n<p>Ergonomic brand checks for Private Fields は、<code>in</code> 演算子を使ったプライベートフィールドの有無の判定を可能にするプロポーザルです。</p>\n<h3>現在の <code>in</code> 演算子</h3>\n<p><code>in</code> 演算子は、オブジェクトが特定の名前のプロパティを持っているかどうかを判定するための二項演算子です。\n左辺にプロパティの名前、右辺にオブジェクトを受け取ります。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> prop1<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"prop1\"</span> <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n</code></pre></div>\n<h3>新しい <code>in</code> 演算子</h3>\n<p>Ergonomic brand checks for Private Fields では、この <code>in</code> 演算子を拡張し、左辺に Private Identifier を取れるようになります。</p>\n<p>Private Identifier は <code>#foo</code> のような形をした特別な識別子で、クラスのプライベートフィールドを表現するのに使われます。</p>\n<p>たとえば、次のコードではクラス <code>Foo</code> は、<code>#prop1</code> というプライベートフィールドを持ちます。\nこのとき <code>#prop1</code> は Private Identifier です。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  #prop1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>拡張された <code>in</code> 演算子では、次のようにしてオブジェクトにプライベートフィールドが含まれるかどうかをチェックできます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\">#prop1 <span class=\"token keyword\">in</span> obj\n</code></pre></div>\n<p>しかし、プライベートフィールドはプライベートなので上記のコードはそのフィールドを持つクラスの中でのみ使うことができます。</p>\n<p>つまり、次のようにクラスの外でプライベートフィールドに対して <code>in</code> を使うとエラーになります。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  #prop1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>#prop1 <span class=\"token keyword\">in</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Uncaught SyntaxError: Private field '#prop1' must be declared in an enclosing class</span>\n</code></pre></div>\n<p>しかし、次のようなコードはエラーになりません。メソッド <code>foo</code> はクラス <code>Foo</code> の中にあるので、Private Identifier である <code>#foo</code> を <code>in</code> 演算子の左辺として使うことができます。\nそして、この <code>foo</code> の中で <code>this</code> は <code>Foo</code> のインスタンスであり、それには当然 <code>#prop1</code> というプライベートプロパティが存在するので、<code>#prop1 in this</code> の結果は <code>true</code> になります。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  #prop1<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">return</span> #prop1 <span class=\"token keyword\">in</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n</code></pre></div>\n<h2>モチベーション</h2>\n<p>存在しないプライベートフィールドにアクセスすると、実行時エラーが発生します。</p>\n<p>その挙動と try / catch を組み合わせて、次のようにしてオブジェクトのクラスを判定できます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  #brand<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">isFoo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">try</span> <span class=\"token punctuation\">{</span>\n      obj<span class=\"token punctuation\">.</span><span class=\"token property-access\">#brand</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword control-flow\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword control-flow\">catch</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword control-flow\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p><code>obj.#brand</code> にアクセスしたとき、<code>obj</code> が Foo のインスタンスでない場合、実行時エラーが発生し <code>catch</code> に入り <code>false</code> が返されます。\nこのようにして、あるオブジェクトが<code>Foo</code>のインスタンスであるかを検証するスタティックメソッドを作れます。</p>\n<p>ですが、このパターンは冗長です。<code>in</code> 演算子を使えばもっと短く書けます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  #brand<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">isFoo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">return</span> #brand <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>これが、このプロポーザルの主なモチベーションです。</p>\n<p><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/instanceof\"><code>instanceof</code> 演算子</a>も基本的にはこの目的のために使えます。しかし <code>instanceof</code> 演算子はプロトタイプに依存するので、プロトタイプを書き換えることでその挙動を変更できます。</p>\n<p>次の例では、 <code>obj</code> は <code>Foo</code> のインスタンスではありませんが、後からプロトタイプを書き換えているので <code>obj instanceof Foo</code> は <code>true</code> になっています。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token known-class-name class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">setPrototypeOf</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>obj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n</code></pre></div>\n<p>なので、より安全にオブジェクトのもとになったクラスを検証したい場合は <code>in</code> 演算子を使うと良いでしょう。</p>\n<h2>参考リンク</h2>\n<ul>\n<li><a href=\"https://tc39.es/ecma262/#prod-RelationalExpression\">https://tc39.es/ecma262/#prod-RelationalExpression</a></li>\n<li><a href=\"https://tc39.es/ecma262/#prod-PrivateIdentifier\">https://tc39.es/ecma262/#prod-PrivateIdentifier</a></li>\n<li><a href=\"https://github.com/tc39/proposal-private-fields-in-in\">https://github.com/tc39/proposal-private-fields-in-in</a></li>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/in\">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/in</a></li>\n</ul>\n","metaData":{"title":"ES2022 と TypeScript 4.5 に入るプライベートフィールドのための in 演算子について","author":"sosukesuzuki","createdAt":"2021-11-11","summary":"ES2022 と TypeScript 4.5 に入る現在 Stage 4 の提案 Ergonomic brand checks for Private Fields についての解説です。","tags":["ECMAScript","TypeScript"],"updatedAt":"2021-11-11"}}},"__N_SSG":true}