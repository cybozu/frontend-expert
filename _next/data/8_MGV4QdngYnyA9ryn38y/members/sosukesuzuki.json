{"pageProps":{"member":{"name":"sosukesuzuki","twitterId":"__sosukesuzuki","githubUsername":"sosukesuzuki","active":true},"posts":[{"slug":"tc39-meeting-2022-01","content":"<p>この記事では2021年01月24日~27日に開催された TC39 meeting 88th で議題に上がったプロポーザルについて紹介します。</p>\n<h2>For Stage 4</h2>\n<p>For Stage 4 の提案はありませんでした。</p>\n<h2>For Stage 3</h2>\n<h3><a href=\"https://github.com/tc39/proposal-array-from-async/\">Array.fromAsync</a></h3>\n<p><strong>Stage 3 にはなりませんでした。</strong></p>\n<p><code>Array.fromAsync</code> は次のようにして非同期イテラブルから配列を生成するスタティックメソッドを追加するプロポーザルです。</p>\n<div><pre><code><span>async</span> <span>function</span> <span>*</span> <span>asyncGen</span> <span>(</span><span>n</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&#x3C;</span> n<span>;</span> i<span>++</span><span>)</span>\n    <span>yield</span> i <span>*</span> <span>2</span><span>;</span>\n<span>}</span>\n<span>const</span> arr <span>=</span> <span>await</span> <span>Array</span><span>.</span><span>fromAsync</span><span>(</span><span>asyncGen</span><span>(</span><span>4</span><span>)</span><span>)</span><span>;</span>\n</code></pre></div>\n<p><a href=\"https://github.com/tc39/proposal-array-from-async/issues/19\">https://github.com/tc39/proposal-array-from-async/issues/19</a> で指摘された問題のため、Stage 3 にはなりませんでした。</p>\n<h2>For Stage 2</h2>\n<h3><a href=\"https://github.com/tc39/proposal-class-brand-check\">Class brand checks</a></h3>\n<p><strong>Stage 2 にはなりませんでした</strong></p>\n<p>Class brand checks は brand check のための新しい構文を導入するプロポーザルです。</p>\n<p>brand check は TC39 内で使われる用語で、<a href=\"https://github.com/tc39/how-we-work/blob/master/terminology.md#brand-check\">https://github.com/tc39/how-we-work/blob/master/terminology.md#brand-check</a> で説明されています。</p>\n<p>brand check とは、雑に言えば「ある値があるデータ型であることを検証すること」です。たとえば <code>Array.isArray</code> は brand check です(<a href=\"https://zenn.dev/sosukesuzuki/articles/e0516a3d4c424e\"><code>instanceof</code> は厳密ではない</a>ため brand check ではありません)。</p>\n<p>以前 brand check の方法の一つである <a href=\"https://github.com/tc39/proposal-private-fields-in-in\">Ergonomic brand checks for private fields</a> についての記事を書いたので興味のある方はそちらもご覧ください。</p>\n<p><div></div></p>\n<p>Class branc check プロポーザルでは <code>class.hasInstance(x)</code> という新しい Meta Property を追加します。これはクラスの中でのみ使うことができ、引数として渡された値が今いるクラスのインスタンスかどうかをチェックします。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  <span>static</span> <span>isFoo</span><span>(</span><span>o</span><span>)</span> <span>{</span>\n    <span>return</span> <span>class</span><span>.</span><span>hasInstance</span><span>(</span>o<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> foo <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span><span>Foo</span><span>.</span><span>isFoo</span><span>(</span>foo<span>)</span><span>)</span><span>;</span> <span>// true</span>\n\n<span>const</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span><span>Foo</span><span>.</span><span>isFoo</span><span>(</span>obj<span>)</span><span>)</span><span>;</span> <span>// false</span>\n</code></pre></div>\n<h2>For Stage 1</h2>\n<h3><a href=\"https://github.com/rbuckton/proposal-enum\">enum</a></h3>\n<p><strong>Stage 1 にはなりませんでした。</strong></p>\n<p>enum は列挙型を実現するためのプロポーザルです。このプロポーザルは 4 年ほど前から存在していましたがまた動き出したようです。</p>\n<p>enum プロポーザルでは次のような構文を導入します。</p>\n<div><pre><code><span>enum</span> <span>SyntaxKind</span> <span>{</span>\n  <span>A</span><span>,</span>\n  <span>B</span><span>,</span>\n  <span>C</span>\n<span>}</span>\n</code></pre></div>\n<p>他のプログラミング言語の enum と構文上は似ています。</p>\n<p>しかし細部の仕様について検討すべき事項が多く、今回のミーティングでは Stage 1 に到達することはありませんでした。<a href=\"https://docs.google.com/presentation/d/14WtGmdWjEYXIXZVWJWpERF98D90_BytceAu7b7DKr5Q/edit#slide=id.g10effb28f4f_0_273\">このスライド</a>に詳しくまとまっているので興味のある方はご覧ください。</p>\n<h3><a href=\"https://github.com/tc39/proposal-reversible-string-split\">Reversible string split</a></h3>\n<p><strong>Stage 1 になりました。</strong></p>\n<p>Reversible string split は可逆(Reversible)の文字列分割のための方法を導入するプロポーザルです。</p>\n<p>JavaScript では <code>String.prototype.split</code> を使って文字列を分割できます。</p>\n<p><div></div></p>\n<div><pre><code><span>const</span> splitted <span>=</span> <span>\"A,B,C,D,E\"</span><span>.</span><span>split</span><span>(</span><span>\",\"</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>splitted<span>)</span><span>;</span> <span>// [ 'A', 'B', 'C', 'D', 'E' ]</span>\n</code></pre></div>\n<p><code>String.prototype.split</code> は第2引数として非負の整数を渡すことで、分割する数を制限できます。</p>\n<div><pre><code><span>const</span> splitted1 <span>=</span> <span>\"A,B,C,D,E\"</span><span>.</span><span>split</span><span>(</span><span>\",\"</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>splitted1<span>)</span><span>;</span> <span>// [ 'A' ]</span>\n\n<span>const</span> splitted2 <span>=</span> <span>\"A,B,C,D,E\"</span><span>.</span><span>split</span><span>(</span><span>\",\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>splitted2<span>)</span><span>;</span> <span>// [ 'A', 'B' ]</span>\n\n<span>const</span> splitted3 <span>=</span> <span>\"A,B,C,D,E\"</span><span>.</span><span>split</span><span>(</span><span>\",\"</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>splitted3<span>)</span><span>;</span> <span>// [ 'A', 'B', 'C' ]</span>\n</code></pre></div>\n<p>JavaScript 以外のいくつかの言語(Perl、PHP、Ruby、Go、Rust、Java など)では第2引数を受け取った <code>String.prototype.split</code> に相当する機能は、次のように文字列の分割を行います。</p>\n<div><pre><code><span>const</span> splitted2 <span>=</span> <span>\"A,B,C,D,E\"</span><span>.</span><span>split</span><span>(</span><span>\",\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>splitted2<span>)</span><span>;</span> <span>// [ 'A', 'B,C,D,E' ]</span>\n</code></pre></div>\n<p>N-1 回分割され、残りの部分が戻り値の配列の末尾に含まれています(戻り値の配列の要素数が N)。</p>\n<p>Reversible string split プロポーザルでは、このような振る舞いを持つ新しいメソッド <code>String.prototype.splitN</code> を導入します。</p>\n<div><pre><code><span>const</span> splitted2 <span>=</span> <span>\"A,B,C,D,E\"</span><span>.</span><span>splitN</span><span>(</span><span>\",\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>splitted2<span>)</span><span>;</span> <span>// [ 'A', 'B,C,D,E' ]</span>\n</code></pre></div>\n<p>このような文字列分割メソッドを使うと、次のようにして分割する前の文字列を取得できます。</p>\n<div><pre><code><span>const</span> value <span>=</span> <span>\"A,B,C,D,E\"</span><span>;</span>\n<span>const</span> separator <span>=</span> <span>\",\"</span><span>;</span>\n<span>const</span> n <span>=</span> <span>2</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span><span>(</span>value<span>.</span><span>splitN</span><span>(</span>separator<span>,</span> n<span>)</span><span>.</span><span>join</span><span>(</span>separator<span>)</span><span>)</span> <span>===</span> value<span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<p>提案の名前に含まれている Reversible というのはこのような可逆性のことを指しているようです。</p>\n<h2>Updates</h2>\n<h3><a href=\"https://github.com/tc39/proposal-symbols-as-weakmap-keys\">Symbols as WeakMap keys</a></h3>\n<p>Symbols as WeakMap keys は Symbol を WeakMap のキーとして使えるようにするためのプロポーザルです。</p>\n<p>現在では一部情報が古くなっていますが以前このプロポーザルについて解説する記事を書いたので興味がある方はそちらもご覧ください。</p>\n<p><div></div></p>\n<p>以前から Symbols as WeakMap keys プロポーザルのモチベーションや基本的な振る舞いについては概ね合意がとれていました。しかし、Well-knwon Symbols やグローバルシンボルレジストリに登録された Symbol (Eternal Symbol と呼ばれている)についてはどのように扱うべきかという点で TC39 メンバー内でも意見が分かれていました。</p>\n<p>今回のミーティングで Symbols as WeakMap keys チャンピョングループは、Eternal Symbol を WeakMap のキーとして使おうとするとエラーが throw されるという振る舞いを選択したことを発表しました。それにともなって、<code>WeakMap.isValidKey(x)</code>、<code>WeakSet.isValidValue(x)</code>、<code>WeakRef.isValidTarget(x)</code>、<code>FinalizationRegistry.isValidTarget(x)</code> などのいくつかのスタティックメソッドが追加される可能性があります。</p>\n<p>しかし議事録によればまだ TC39 メンバーの中で意見が分かれているため仕様の決定には時間がかかりそうです。</p>\n<h2>参考リンク</h2>\n<ul>\n<li>TC39\n<ul>\n<li><a href=\"https://github.com/tc39/agendas/blob/main/2022/01.md\">agendas/01.md at main · tc39/agendas</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/main/meetings/2022-01/jan-24.md\">notes/jan-24.md at main · tc39/notes</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/main/meetings/2022-01/jan-25.md\">notes/jan-25.md at main · tc39/notes</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/main/meetings/2022-01/jan-26.md\">notes/jan-26.md at main · tc39/notes</a></li>\n<li><a href=\"https://github.com/tc39/proposal-array-from-async/\">Proposal Array.fromAsync</a></li>\n<li><a href=\"https://github.com/tc39/proposal-symbols-as-weakmap-keys\">Proposal Symbols as WeakMap keys</a></li>\n<li><a href=\"https://github.com/tc39/proposal-class-brand-check\">Proposal <code>class.hasInstance()</code></a></li>\n<li><a href=\"https://github.com/rbuckton/proposal-enum\">Proposal enum</a></li>\n<li><a href=\"https://github.com/tc39/proposal-reversible-string-split\">Proposal Reversible string split</a></li>\n</ul>\n</li>\n<li>Babel\n<ul>\n<li><a href=\"https://github.com/babel/proposals/issues/80\">Jan 2022 · Issue #80 · babel/proposals</a></li>\n</ul>\n</li>\n</ul>\n","metaData":{"title":"ECMAScriptの最新動向 2022年01月版","author":"sosukesuzuki","createdAt":"2022-03-09","summary":"2021年01月24日~27日に開催された TC39 meeting 88th の内容を紹介します","tags":["TC39","ECMAScript"],"updatedAt":"2022-03-09"}},{"slug":"tc39-meeting-2021-12","content":"<p>TC39 の 87 回目のミーティングが 12月14日 ~ 12月15日に開催されました。このミーティングで議題に上がった提案とそのステージの移動について紹介します。</p>\n<h2>For Stage 4</h2>\n<p><strong>For Stage 4 の提案はありませんでした</strong></p>\n<h2>For Stage 3</h2>\n<h3><a href=\"https://github.com/tc39/proposal-array-grouping\">Array Grouping</a></h3>\n<p><strong>Stage 3 になりました</strong></p>\n<p>Array Grouping は <code>Array.prototype.groupBy</code> と <code>Array.prototype.groupByToMap</code> を追加するプロポーザルです。</p>\n<p>2021 年 10 月のミーティングで Stage 2 になったばかりですが、今回のミーティングで Stage 3 になりました。</p>\n<p>また、今回から <code>Array.prototype.groupByToMap</code> が追加されています。</p>\n<p>これは <code>groupBy</code> の結果が <code>Map</code> になったものです。</p>\n<div><pre><code><span>const</span> array <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>;</span>\n<span>const</span> odd  <span>=</span> <span>{</span> <span>odd</span><span>:</span> <span>true</span> <span>}</span><span>;</span>\n<span>const</span> even <span>=</span> <span>{</span> <span>even</span><span>:</span> <span>true</span> <span>}</span><span>;</span>\n<span>const</span> map <span>=</span> array<span>.</span><span>groupByToMap</span><span>(</span><span>(</span><span>num<span>,</span> index<span>,</span> array</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> num <span>%</span> <span>2</span> <span>===</span> <span>0</span> <span>?</span> even<span>:</span> odd<span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>map<span>)</span><span>;</span> <span>// Map { {odd: true}: [1, 3, 5], {even: true}: [2, 4] }</span>\n</code></pre></div>\n<h2>For Stage 2</h2>\n<h3><a href=\"https://github.com/tc39/proposal-array-from-async/\">Array.fromAsync</a></h3>\n<p><strong>Stage 2 になりました</strong></p>\n<p><code>Array.fromAsync</code> は非同期イテラブルから配列を生成するためのスタティックメソッドを追加するプロポーザルです。</p>\n<p>JavaScript では <code>Array.from</code> を使ってイテラブルから配列を生成できます。しかし、非同期イテラブルから配列を生成することはできません。</p>\n<p>このプロポーザルによって追加される <code>Array.fromAsync</code> メソッドを使うと次のようにして非同期イテラブルから配列を生成できます。</p>\n<div><pre><code><span>async</span> <span>function</span> <span>*</span> <span>asyncGen</span> <span>(</span><span>n</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&#x3C;</span> n<span>;</span> i<span>++</span><span>)</span>\n    <span>yield</span> i <span>*</span> <span>2</span><span>;</span>\n<span>}</span>\n<span>const</span> arr <span>=</span> <span>await</span> <span>Array</span><span>.</span><span>fromAsync</span><span>(</span><span>asyncGen</span><span>(</span><span>4</span><span>)</span><span>)</span><span>;</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/tc39/proposal-regexp-r-escape\">RegExp <code>\\R</code> escape</a></h3>\n<p><strong>Stage 2 になりませんでした</strong></p>\n<p>RegExp <code>\\R</code> escape は以前 <a href=\"https://github.com/rbuckton/proposal-regexp-features\">RegExp Language Features</a> として提案されていた正規表現の機能群の１つで、正規表現内で line terminator とシンプルにマッチングさせるために新しく <code>\\R</code> を導入する提案です。</p>\n<p>この機能は <code>u</code> もしくは <code>v</code> フラグが有効になっているときのみ有効になります。そして、大まかには次のパターンと等価です。</p>\n<div><pre><code><span>(</span><span>?</span><span>></span>\\r\\n<span>?</span><span>|</span><span>[</span>\\x0A<span>-</span>\\x0C\\x85\\u<span>{</span><span>2028</span><span>}</span>\\u<span>{</span><span>2029</span><span>}</span><span>]</span><span>)</span>\n</code></pre></div>\n<p>この正規表現の機能は Perl をはじめとする多くの正規表現エンジンに実装されていて、TC39 においてもそのユースケースは認められているようです。</p>\n<p>しかし、<a href=\"https://github.com/tc39/proposal-regexp-set-notation\">RegExp Set Notation Proposal</a> の sequece properties によって同等の機能が実現できる可能性があるためその方向で調査しなおすべきだという結論になり Stage 2 には到達しませんでした。</p>\n<h3><a href=\"https://github.com/tc39/proposal-regexp-modifiers\">RegExp Modifiers</a></h3>\n<p><strong>Stage 2 になりました</strong></p>\n<p>RegExp Modifiers は <code>\\R</code> escape と同じようにもともと RegExp Language Features の機能の１つでした。</p>\n<p>この提案は正規表現パターン内でのフラグの変更を可能にします。</p>\n<p>例を示します。</p>\n<p>次の例中の正規表現パターン全体には <code>i</code> フラグが適用されてます。しかし２つめの <code>[a-z]</code> は <code>?-i:</code> という RegExp Modifiers の構文を使って <code>i</code> フラグを無効にしてます。このとき一文字目では大文字小文字が無視されるものの、二文字目では大文字小文字が無視されません。</p>\n<p>したがってこのパターンは <code>\"ab\"</code> や <code>\"Ab\"</code> にはマッチし <code>\"aB\"</code> にはマッチしません。</p>\n<div><pre><code><span>const</span> re1 <span>=</span> <span><span>/</span><span><span>^</span><span><span>[</span><span>a<span>-</span>z</span><span>]</span></span><span>(</span><span>?</span>-i:<span><span>[</span><span>a<span>-</span>z</span><span>]</span></span><span>)</span><span>$</span></span><span>/</span><span>i</span></span><span>;</span>\nre1<span>.</span><span>test</span><span>(</span><span>\"ab\"</span><span>)</span><span>;</span> <span>// true</span>\nre1<span>.</span><span>test</span><span>(</span><span>\"Ab\"</span><span>)</span><span>;</span> <span>// true</span>\nre1<span>.</span><span>test</span><span>(</span><span>\"aB\"</span><span>)</span><span>;</span> <span>// false</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/tc39/proposal-regexp-buffer-boundaries\">RegExp Buffer Boundaries</a></h3>\n<p><strong>Stage 2 になりました</strong></p>\n<p>RegExp Buffer Boundaries も RegExp Language Features の機能の１つでした。</p>\n<p>この提案は、それぞれ入力の最初と最後にマッチする <code>\\A</code> と <code>\\z</code> を導入します。<code>m</code> フラグの影響を受けないことを除けば <code>^</code> と <code>$</code> に似ています。</p>\n<p><code>^</code> と <code>$</code> はそれぞれ最初と最後にマッチしますが、<code>m</code> フラグが有効になっているときは行頭と行末にマッチします。しかし RegExp Buffer Boundaries が導入する <code>\\A</code> と <code>\\z</code> は、たとえ <code>m</code> フラグが有効であっても入力の最初と最後にマッチします。</p>\n<p>例を示します。</p>\n<div><pre><code><span>const</span> re <span>=</span> <span><span>/</span><span><span>\\A</span>foo<span>|</span><span>^</span>bar</span><span>/</span><span>um</span></span><span>;</span>\n</code></pre></div>\n<p>このパターンでは <code>foo</code> に <code>\\A</code> がついています。したがって入力の最初が <code>foo</code> の文字列にマッチします。</p>\n<div><pre><code>re<span>.</span><span>test</span><span>(</span><span>\"foo\"</span><span>)</span><span>;</span> <span>// true</span>\nre<span>.</span><span>test</span><span>(</span><span>\"foo\\n\"</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<p>しかし入力の最初ではなく行頭が <code>foo</code> の文字列にはマッチしません。</p>\n<div><pre><code>re<span>.</span><span>test</span><span>(</span><span>\"\\nfoo\"</span><span>)</span><span>;</span> <span>// false</span>\n</code></pre></div>\n<p><code>bar</code> には <code>^</code> がついています。パターン全体で <code>m</code> フラグが有効になっているので、入力の先頭と行頭が <code>bar</code> の文字列にマッチします。</p>\n<div><pre><code>re<span>.</span><span>test</span><span>(</span><span>\"bar\"</span><span>)</span><span>;</span> <span>// true</span>\nre<span>.</span><span>test</span><span>(</span><span>\"bar\\n\"</span><span>)</span><span>;</span> <span>// true</span>\nre<span>.</span><span>test</span><span>(</span><span>\"\\nbar\"</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<h2>For Stage 1</h2>\n<h2>Updates</h2>\n<p>ステージの移動はないものの、アップデートがあった提案です。</p>\n<h3><a href=\"https://github.com/tc39/proposal-temporal\">Temporal</a></h3>\n<p>いくつかの仕様上の軽微な修正がありました。修正箇所について説明した<a href=\"https://ptomato.name/talks/tc39-2021-12/#1\">スライド</a>が公開されています。</p>\n<h3><a href=\"https://github.com/tc39/proposal-decimal\">Decimal</a></h3>\n<p>Decimal は現在 Stage 1 ですが、2022 年に Stage 2 に到達することを目指しているそうです。進捗を共有するための<a href=\"https://drive.google.com/file/d/1qdieei11dZgDY_KnJhSBcFyHTMZOmCJr/view\">スライド</a>が公開されています。</p>\n<h3><a href=\"https://github.com/tc39/proposal-destructuring-private\">Destructuring Private Fields</a></h3>\n<p>Destructuring Private Fields が提案された当初は小さな修正で十分だと考えられていました。しかし真剣に検討してみるといくつかの仕様上の難しい問題が明らかになったそうです。そこで再度レビュワーを募りレビューをやり直すことが決定しました。</p>\n<h3><a href=\"https://github.com/tc39/proposal-shadowrealm\">Shadow Realms</a></h3>\n<p>いくつかの仕様上の重要な変更があったようです。詳しくは<a href=\"https://docs.google.com/presentation/d/12PM5c4_yUnqXHjvACh8HEN5oJwgei-0T0hX_hlqjfDU/edit#slide=id.ge435a9058a_0_0\">スライド</a>に記載されています。</p>\n<h3><a href=\"https://github.com/tc39/proposal-record-tuple/\">Records and Tuples</a></h3>\n<p>Record と Tuple の中で通常のオブジェクトを扱う方法について議論されました。その方法とその懸念についての Decision Tree が<a href=\"https://drive.google.com/file/d/1lVYn8_sHecqxW08vN5Tu7rXZn7GemBqO/view\">スライド</a>として公開されています。</p>\n<h2>Normative Changes</h2>\n<h3><a href=\"https://github.com/tc39/ecma262/pull/2106\"><code>import.meta[Symbol.toStringTag]</code> の追加</a></h3>\n<p><strong>合意は得られませんでした</strong></p>\n<p><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag\"><code>Symbol.toStringTag</code></a> という Well-known Symbol があります。\nこの Symbol は <code>Object.prototype.toString()</code> によって表示される文字列の決定に使われます。</p>\n<p>具体的な例を示します。</p>\n<p>オブジェクト <code>foo</code> の <code>[Symbol.toStringTag]</code> に <code>\"I'm foo\"</code> という文字列をセットしておくと、<code>foo.toString()</code> は <code>[object I'm foo]</code> になります。</p>\n<div><pre><code><span>const</span> foo <span>=</span> <span>{</span>\n  <span>[</span><span>Symbol</span><span>.</span><span>toStringTag</span><span>]</span><span>:</span> <span>\"I'm foo\"</span>\n<span>}</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>foo<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// \"[object I'm foo]\"</span>\n</code></pre></div>\n<p>今回のミーティングでは <code>import.meta</code> の <code>[Symbol.toStringTag]</code> に <code>\"ImportMeta\"</code> という文字列を設定するという修正について議論されました。</p>\n<p>この挙動についての Issue は <code>import.meta</code> の策定時にも存在しましたが、そのときすでに <code>import.meta</code> が Stage 4 を達成していたことからクローズされました。</p>\n<p>そして今回のミーティングでもこの仕様の修正についての合意は得られませんでした。この修正のための Pull Request が作成された時点で以下のような懸念が公開されていました。</p>\n<ul>\n<li><code>import.meta</code> は、ECMAScript の範囲では <a href=\"https://tc39.es/ecma262/#sec-hostgetimportmetaproperties\"><code>HostGetImportMetaProperties</code></a> というホスト定義の abstract operation によって中身が決定されるオブジェクトであるということしか決まっておらず、ホストにとって必要であればホスト側で <code>import.meta</code> の <code>Symbol.toStringTag</code> を定義できる。</li>\n<li>仕様内で作成される他のオブジェクトとは異なり、<code>import.meta</code> はホストのデータによって生成されるものであり、ECMAScript の範囲でプロパティを生成することを考慮したものではない。</li>\n</ul>\n<h2>参考リンク</h2>\n<ul>\n<li>TC39\n<ul>\n<li><a href=\"https://github.com/tc39/agendas/blob/main/2021/12.md\">Agenda for the 87th meeting of Ecma TC39</a></li>\n<li><a href=\"https://github.com/tc39/ecma262/pull/2106\">Normative: Add import.meta[Symbol.toStringTag]</a></li>\n<li><a href=\"https://github.com/tc39/proposal-array-grouping\">Proposal Array Grouping</a></li>\n<li><a href=\"https://github.com/tc39/proposal-shadowrealm\">Proposal Shadow Realms</a></li>\n<li><a href=\"https://github.com/tc39/proposal-array-from-async/\">Proposal <code>Array.fromAsync</code></a></li>\n<li><a href=\"https://github.com/rbuckton/proposal-regexp-features\">Proposal RegExp Language Features</a></li>\n<li><a href=\"https://github.com/tc39/proposal-regexp-r-escape\">Proposal RegExp <code>\\R</code> escape</a></li>\n<li><a href=\"https://github.com/tc39/proposal-regexp-set-notation\">Proposal RegExp Set Notation</a></li>\n<li><a href=\"https://github.com/tc39/proposal-regexp-buffer-boundaries\">Proposal RegExp Buffer Boundaries</a></li>\n<li><a href=\"https://github.com/tc39/proposal-regexp-modifiers\">Proposal RegExp Modifiers</a></li>\n<li><a href=\"https://github.com/tc39/proposal-temporal\">Proposal Temporal</a></li>\n<li><a href=\"https://github.com/tc39/proposal-shadowrealm\">Proposal Shadow Realms</a></li>\n<li><a href=\"https://github.com/tc39/proposal-record-tuple/\">Proposal Records and Tuples</a></li>\n<li><a href=\"https://github.com/tc39/proposal-destructuring-private\">Proposal Destructuring Private Fields</a></li>\n</ul>\n</li>\n<li>Babel\n<ul>\n<li><a href=\"https://github.com/babel/proposals/issues/78\">Dec 2021 · Issue #78 · babel/proposals</a></li>\n</ul>\n</li>\n<li>ECMA262\n<ul>\n<li><a href=\"https://tc39.es/ecma262/#prod-ImportMeta\"><code>import.meta</code></a></li>\n<li><a href=\"https://tc39.es/ecma262/#sec-hostgetimportmetaproperties\"><code>HostGetImportMetaProperties</code></a></li>\n</ul>\n</li>\n</ul>\n","metaData":{"title":"ECMAScriptの最新動向 2021年12月版","author":"sosukesuzuki","createdAt":"2022-01-24","summary":"2021年12月14日~15日に開催された TC39 meeting 87th の内容を紹介します","tags":["TC39","ECMAScript"],"updatedAt":"2022-01-24"}},{"slug":"strings-as-import-export","content":"<p>11 月 11 日に、以前から一部で注目されていた<a href=\"https://github.com/tc39/ecma262/pull/2154\">ある Pull Request</a> が <a href=\"https://github.com/tc39/ecma262\">tc39/ecma262</a> にマージされました。</p>\n<p>この Pull Request がマージされたことで、識別子ではなく文字列リテラルを使った import/export が可能になりました。</p>\n<p>この仕様変更はプロポーザルという形で扱われてはいませんが、構文上の影響があるので、JavaScript ユーザーとして知っておくに越したことはないものになります。</p>\n<h2>概要</h2>\n<p>まず具体例を示します。</p>\n<p>今回の変更によって、次のように import/export する際の名前として文字列リテラルを使えるようになります。</p>\n<div><pre><code><span>const</span> foo <span>=</span> <span>\"foo\"</span><span>;</span>\n<span>export</span> <span>{</span> foo <span>as</span> <span>\"😃 hey hey\"</span> <span>}</span><span>;</span>\n</code></pre></div>\n<div><pre><code><span>import</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>as</span> foo <span>}</span> <span>from</span> <span>\"./module.js\"</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>foo<span>)</span><span>;</span> <span>// foo</span>\n</code></pre></div>\n<p>基本的にはこれだけです。</p>\n<h2>詳解</h2>\n<p>ここからは仕様上の用語を使って解説をします。</p>\n<p>この変更が入る前の ECMAScript では <a href=\"https://tc39.es/ecma262/#prod-ImportSpecifier\"><code>ImportSpecifier</code></a> で <code>as</code> を使う場合 <code>as</code> の左側は <a href=\"https://tc39.es/ecma262/#prod-IdentifierName\"><code>IdentifierName</code></a> でなければいけませんでした。\nまた <a href=\"https://tc39.es/ecma262/#prod-ExportSpecifier\"><code>ExportSpecifier</code></a> は、単一の <code>IdentifierName</code> もしくは、<code>as</code> を使う場合は <code>as</code> の左側と右側は両方とも <code>IdentifierName</code> でなければいけませんでした。</p>\n<p>今回の変更によって、新たに <a href=\"https://tc39.es/ecma262/#prod-ModuleExportName\"><code>ModuleExportName</code></a> という構文が追加されました。<code>ModuleExportName</code> は、<code>IdentifierName</code> もしくは <a href=\"https://tc39.es/ecma262/#prod-StringLiteral\"><code>StringLiteral</code></a> の形をとります。\nたとえば、識別子 <code>foo</code> や 文字列リテラル <code>\"😃 hey hey\"</code> は <code>ModuleExportName</code> です。</p>\n<p>そして、<code>ImportSpecifier</code> で <code>as</code> を使う場合 <code>as</code> の左側は <code>ModuleExportName</code> の形をとるようになりました。したがって、次の例の <code>import</code> 文はすべて構文として妥当です。</p>\n<div><pre><code><span>import</span> <span><span>{</span> foo <span>}</span></span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>import</span> <span><span>{</span> foo <span>as</span> bar <span>}</span></span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>import</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>as</span> baz <span>}</span> <span>from</span> <span>\"mod\"</span><span>;</span>\n</code></pre></div>\n<p><code>ExportSpecifier</code> は、単一の <code>ModuleExportName</code> もしくは、 <code>as</code> を使う場合 <code>as</code> の左側と右側は両方とも <code>ModuleExportName</code> の形をとるようになりました。したがって、次の例の <code>export</code> 文はすべて構文として妥当です。</p>\n<div><pre><code><span>export</span> <span><span>{</span> foo <span>}</span></span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>export</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>}</span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>export</span> <span><span>{</span> foo <span>as</span> foo <span>}</span></span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>export</span> <span>{</span> foo <span>as</span> <span>\"😃 hey hey\"</span> <span>}</span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>export</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>as</span> foo <span>}</span> <span>from</span> <span>\"mod\"</span><span>;</span>\n<span>export</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>as</span> <span>\"😃 hey hey\"</span> <span>}</span> <span>from</span> <span>\"mod\"</span><span>;</span>\n</code></pre></div>\n<p>ただし <code>ExportSpecifier</code> の <code>ModuleExportName</code> を <code>StringLiteral</code> にできるのは、その <code>ExportSpecifier</code> を含む <a href=\"https://tc39.es/ecma262/#prod-ExportDeclaration\"><code>ExportDeclaration</code></a> に <a href=\"https://tc39.es/ecma262/#prod-FromClause\"><code>FromClause</code></a> が存在する場合のみです。</p>\n<p>たとえば、次のコードは <code>ExportDeclaration</code> に <code>FromClause</code> が存在しないので <code>ExportSpecifier</code> で <code>StringLiteral</code> を使うことはできません。</p>\n<div><pre><code><span>// できない</span>\n<span>export</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>}</span><span>;</span>\n</code></pre></div>\n<p>一方で、次のコードは <code>FromClause</code> が存在するので、<code>ExportSpecifier</code> で <code>StringLiteral</code> を使うことができます。</p>\n<div><pre><code><span>// できる</span>\n<span>export</span> <span>{</span> <span>\"😃 hey hey\"</span> <span>}</span> <span>from</span> <span>\"mod\"</span><span>;</span>\n</code></pre></div>\n<h2>文字列の制約</h2>\n<p><code>StringLiteral</code> は通常の JavaScript の文字列リテラルです。たとえば <code>\"foo\"</code> とか <code>\"bar\"</code> みたいな形をしたものです。</p>\n<p><code>ModuleExportName</code> は <code>StringLiteral</code> を含むので、全ての文字列リテラルを <code>ModuleExportName</code> として使えるようにみえますが、実際には少々異なります。<code>ModuleExportName</code> として使える <code>StringLiteral</code> には制限があります。</p>\n<p><strong><code>ModuleExportName</code> として使える <code>StringLiteral</code> は、<a href=\"https://www.unicode.org/glossary/#well_formed_code_unit_sequence\">Well-Formed Code Unit Sequence</a> でなければいけません。</strong>\nこのことは、<a href=\"https://tc39.es/ecma262/#sec-module-semantics\">Module Semantics</a> の Eary Errros 内の <a href=\"https://tc39.es/ecma262/#_ref_6583\">https://tc39.es/ecma262/#_ref_6583</a> に記載されています。</p>\n<h3>Well-Formed Code Unit Sequence とは</h3>\n<p>JavaScript の文字列は UTF-16 でエンコードされます。そのため、実際には JavaScript の文字列というのは 16 ビットの整数で表現される Unicode のコードユニットの並びでしかありません。</p>\n<p>UTF-16 では基本的に 1 文字につき 16 ビットで表現されます。しかし、Unicode の BMP(基本多言語面)に収まらない文字は 16 ビットのコードユニットを二つ並べたペアで表現します。</p>\n<p>たとえば、ひらがなの <code>あ</code> は BMP に含まれており、一つのコードユニット(<code>0x3042</code>)で表されます。</p>\n<div><pre><code><span>console</span><span>.</span><span>log</span><span>(</span><span>\"\\u3042\"</span><span>)</span><span>;</span> <span>// あ</span>\n</code></pre></div>\n<p>一方で、<code>𠮟</code>(<code>叱</code> ではないことに注意) は BMP に含まれないので、二つのコードユニット(<code>0xD842</code> と <code>0xDF9F</code>)で表されます。このようなコードユニットのペアを、サロゲートペアといいます。</p>\n<div><pre><code><span>console</span><span>.</span><span>log</span><span>(</span><span>\"\\uD842\\uDF9F\"</span><span>)</span><span>;</span> <span>// 𠮟</span>\n</code></pre></div>\n<p>前述のとおり、JavaScript の文字列は 16 ビットの整数で表現されるコードユニットの並びでしかありません。したがって、<code>𠮟</code> を構成する二つのコードユニットである <code>0xD842</code> と <code>0xDF9F</code> のうち一つだけを含む文字列も作ることができます。</p>\n<div><pre><code><span>const</span> str <span>=</span> <span>\"\\uD842\"</span><span>;</span>\n</code></pre></div>\n<p>しかし、<code>0xD842</code> 単体に対応する文字は Unicode には存在しません。</p>\n<p>このような、<strong>対になっていないサロゲートペアを含むような文字列は Well-Formed Code Unit Sequence ではありません。</strong></p>\n<p>逆に、対になっていないサロゲートペアを許容しないような文字列を <strong>Well-Formed Code Unit Sequence</strong> といいます。つまり、大雑把にいえば「ちゃんと文字になっているコードユニットで構成された文字列」ということです。</p>\n<p>ちなみに、このような Well-Formed な文字列は WebIDL では <a href=\"https://developer.mozilla.org/ja/docs/Web/API/USVString\">USVString</a> と呼ばれています。</p>\n<h3>新しい Abstract Operation <code>IsStringWellFormedUnicode</code></h3>\n<p>この仕様の変更に伴って、<a href=\"https://tc39.es/ecma262/#sec-isstringwellformedunicode\"><code>IsStringWellFormedUnicode</code></a> という新しい Abstract Operation が追加されました。</p>\n<p>この Abstract Operation は、引数の文字列が Well-Formed Code Unit Sequence かどうかを判定します。</p>\n<p>前述した <code>ModuleExportName</code> のための Early Errors では、この <code>IsStringWellFormedUnicode</code> Abstract Operation を使って <code>StringLiteral</code> が Well-Formed Code Unit Sequence かどうかの判定を行います。そしてもし Well-Formed Code Unit Sequence でなければ Syntax Error になります。</p>\n<h2>仕様変更のモチベーション</h2>\n<p>実はこの仕様の変更は、今の Web の仕様ではほとんど役に立つことはありません。</p>\n<p>この変更が行われたモチベーションは、<strong>将来的に</strong> WebAssembly の Module との相互運用性を向上させるためです。</p>\n<p>この背景を理解するために、おさえておくべき前提が二つあります。</p>\n<p>１つ目は、WebAssembly の Module では関数を export するときに文字列で名前をつけるということです。\nたとえば次の例では <code>$add</code> という関数を <code>\"add\"</code> という名前で export しています。</p>\n<div><pre><code><span>(</span><span>module</span>\n  <span>(</span><span>func</span> <span>$add</span> <span>(</span><span>param</span> <span>$lhs</span> <span>i32</span><span>)</span> <span>(</span><span>param</span> <span>$rhs</span> <span>i32</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span>\n    <span>local</span>.get <span>$lhs</span>\n    <span>local</span>.get <span>$rhs</span>\n    <span>i32<span>.</span>add</span><span>)</span>\n  <span>(</span><span>export</span> <span>\"add\"</span> <span>(</span><span>func</span> <span>$add</span><span>)</span><span>)</span>\n<span>)</span>\n</code></pre></div>\n<p>２つ目は、WebAssembly の Module を JavaScript から import できるようにしたい、という動きがあるということです。<a href=\"https://github.com/WebAssembly/esm-integration\">WebAsembly/esm-integration</a> などで、その動きを見ることができます。</p>\n<p>簡単にいえば、次のようにして簡単に WebAssembly の Module を JavaScript から扱えるようにしたいということです。</p>\n<div><pre><code><span>import</span> <span><span>{</span> add <span>}</span></span> <span>from</span> <span>\"foo.wasm\"</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span> <span>// 3</span>\n</code></pre></div>\n<p>現在の WebAssembly および ECMAScript の仕様では、このような形で JavaScript 側から WebAssembly の Module を読み込むことはできません。</p>\n<p>これらを前提として上で、次の例について考えます。</p>\n<p>この例は前述したものとほとんど変わりませんが、<code>export</code> の後ろが <code>\"add\"</code> ではなく <code>\"+\"</code> になっています。<code>export</code> の後ろには文字列を置くことができるので、これは妥当な Module です。</p>\n<div><pre><code><span>(</span><span>module</span>\n  <span>(</span><span>func</span> <span>$add</span> <span>(</span><span>param</span> <span>$lhs</span> <span>i32</span><span>)</span> <span>(</span><span>param</span> <span>$rhs</span> <span>i32</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span>\n    <span>local</span>.get <span>$lhs</span>\n    <span>local</span>.get <span>$rhs</span>\n    <span>i32<span>.</span>add</span><span>)</span>\n  <span>(</span><span>export</span> <span>\"+\"</span> <span>(</span><span>func</span> <span>$add</span><span>)</span><span>)</span>\n<span>)</span>\n</code></pre></div>\n<p>将来、WebAssembly の Module を JavaScript から import できるようになったときに、このモジュールから <code>+</code> 関数を named import したいとします。\n<strong>しかし、<code>+</code> は <code>IdentifierName</code> ではないので、今までの ECMAScript の仕様では named import できませんでした。</strong></p>\n<div><pre><code><span>// できない</span>\n<span>import</span> <span><span>{</span> <span>+</span> <span>}</span></span> <span>from</span> <span>\"foo.wasm\"</span><span>;</span>\n</code></pre></div>\n<div><pre><code><span>// できない</span>\n<span>import</span> <span><span>{</span> <span>+</span> <span>as</span> add <span>}</span></span> <span>from</span> <span>\"foo.wasm\"</span><span>;</span>\n</code></pre></div>\n<p>今回の変更によって <code>ImportSpecifier</code> の <code>as</code> の左側に <code>StringLiteral</code> を置けるようになったことで、次のように書るようになりました。</p>\n<div><pre><code><span>// ES2022 でできる</span>\n<span>import</span> <span>{</span> <span>\"+\"</span> <span>as</span> add <span>}</span> <span>from</span> <span>\"foo.wasm\"</span><span>;</span>\n\n<span>console</span><span>.</span><span>log</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span> <span>// 3</span>\n</code></pre></div>\n<p>このような書き方は ES2022 では構文上は妥当ですが、実際にはまだ WebAssembly の import はできません。</p>\n<p>また、<code>ModuleExportName</code> の <code>StringLiteral</code> が Well-Formed Code Unit Sequence でなければならないという制約が存在するのも、WebAssembly との相互運用のためです。\nWebAssembly のテキストフォーマットで <code>export</code> の後に続く文字列は Well-Formed Code Unit Sequence でなければいけないので、それと統一させたのでしょう。</p>\n<h2>参考リンク</h2>\n<ul>\n<li>TC39\n<ul>\n<li><a href=\"https://github.com/tc39/ecma262/pull/2154\">Normative: Arbitrary module namespace identifier names by bmeck · Pull Request #2154 · tc39/ecma262</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/master/meetings/2020-09/sept-21.md#arbitrary-strings-as-exportimport-names\">Arbitrary module namespace identifier names · tc39/notes/notes/sept-21.md</a></li>\n<li><a href=\"https://github.com/tc39/proposal-import-reflection\">tc39/proposal-import-reflection</a></li>\n</ul>\n</li>\n<li>Babel\n<ul>\n<li><a href=\"https://github.com/babel/babel/pull/13195\">Parse string export names by default (<code>moduleStringNames</code>) by nicolo-ribaudo · Pull Request #13195 · babel/babel</a></li>\n<li><a href=\"https://babeljs.io/blog/2020/10/15/7.12.0#imports-and-exports-with-string-names-12091httpsgithubcombabelbabelpull12091\">7.12.0 Released: TypeScript 4.1, strings as import/export names, and class static blocks · Babel</a></li>\n</ul>\n</li>\n<li>MDN\n<ul>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Glossary/Identifier\">Identifier (識別子) - MDN Web Docs 用語集: ウェブ関連用語の定義</a></li>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Web/API/USVString\">USVString - Web API | MDN</a></li>\n</ul>\n</li>\n<li>ECMA262\n<ul>\n<li><a href=\"https://tc39.es/ecma262/#prod-ImportSpecifier\">ImportSpecifier · ECMAScript® 2022 Language Specification</a></li>\n<li><a href=\"https://tc39.es/ecma262/#prod-ExportSpecifier\">ExportSpecifier · ECMAScript® 2022 Language Specification</a></li>\n<li><a href=\"https://tc39.es/ecma262/#prod-ModuleExportName\">ModuleExportName · ECMAScript® 2022 Language Specification</a></li>\n<li><a href=\"https://tc39.es/ecma262/#sec-isstringwellformedunicode\">IsStringWellFormedUnicode · ECMAScript® 2022 Language Specification</a></li>\n</ul>\n</li>\n<li>Unicode\n<ul>\n<li><a href=\"https://www.unicode.org/glossary/#well_formed_code_unit_sequence\">Well-Formed Code Unit Sequence · Glossary of Unicode Terms</a></li>\n</ul>\n</li>\n<li>WebAssembly\n<ul>\n<li><a href=\"https://github.com/WebAssembly/esm-integration\">WebAssembly/esm-integration: ECMAScript module integration</a></li>\n<li><a href=\"https://webassembly.github.io/spec/core/text/values.html#names\">Values — WebAssembly 1.1 (Draft 2021-12-02)</a></li>\n<li><a href=\"https://github.com/WebAssembly/esm-integration/issues/39\">ESM isn't suited for importing objects containing non-JavaScript identifiers · Issue #39 · WebAssembly/esm-integration</a></li>\n</ul>\n</li>\n</ul>\n","metaData":{"title":"なぜ ES2022 で文字列リテラルを使った import/export ができるようになるのか","author":"sosukesuzuki","createdAt":"2021-12-06","summary":"ES2022 に含まれる予定の、識別子ではなく文字列リテラルを使って import/export できるようになる ECMAScript の仕様変更について解説します","tags":["ECMAScript"],"updatedAt":"2021-12-06"}},{"slug":"ergonomic-brand-checks-for-private-fields","content":"<p>2021年7月に行われた TC39 ミーティングで <a href=\"https://github.com/tc39/proposal-private-fields-in-in\">Ergonomic brand checks for Private Fields</a> というプロポーザルが Stage 4 になりました。\nこのプロポーザルは、ES2022 に含まれる予定です。また、<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-rc/#private-field-presence-checks\">TypeScript 4.5 にも含まれる予定です</a>。</p>\n<p>この記事では、Ergonomic brand checks for Private Fields について解説します。</p>\n<h2>概要</h2>\n<p>Ergonomic brand checks for Private Fields は、<code>in</code> 演算子を使ったプライベートフィールドの有無の判定を可能にするプロポーザルです。</p>\n<h3>現在の <code>in</code> 演算子</h3>\n<p><code>in</code> 演算子は、オブジェクトが特定の名前のプロパティを持っているかどうかを判定するための二項演算子です。\n左辺にプロパティの名前、右辺にオブジェクトを受け取ります。</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span> <span>prop1</span><span>:</span> <span>1</span> <span>}</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span><span>\"prop1\"</span> <span>in</span> obj<span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<h3>新しい <code>in</code> 演算子</h3>\n<p>Ergonomic brand checks for Private Fields では、この <code>in</code> 演算子を拡張し、左辺に Private Identifier を取れるようになります。</p>\n<p>Private Identifier は <code>#foo</code> のような形をした特別な識別子で、クラスのプライベートフィールドを表現するのに使われます。</p>\n<p>たとえば、次のコードではクラス <code>Foo</code> は、<code>#prop1</code> というプライベートフィールドを持ちます。\nこのとき <code>#prop1</code> は Private Identifier です。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  #prop1<span>;</span>\n<span>}</span>\n</code></pre></div>\n<p>拡張された <code>in</code> 演算子では、次のようにしてオブジェクトにプライベートフィールドが含まれるかどうかをチェックできます。</p>\n<div><pre><code>#prop1 <span>in</span> obj\n</code></pre></div>\n<p>しかし、プライベートフィールドはプライベートなので上記のコードはそのフィールドを持つクラスの中でのみ使うことができます。</p>\n<p>つまり、次のようにクラスの外でプライベートフィールドに対して <code>in</code> を使うとエラーになります。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  #prop1<span>;</span>\n<span>}</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>#prop1 <span>in</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>// Uncaught SyntaxError: Private field '#prop1' must be declared in an enclosing class</span>\n</code></pre></div>\n<p>しかし、次のようなコードはエラーになりません。メソッド <code>foo</code> はクラス <code>Foo</code> の中にあるので、Private Identifier である <code>#foo</code> を <code>in</code> 演算子の左辺として使うことができます。\nそして、この <code>foo</code> の中で <code>this</code> は <code>Foo</code> のインスタンスであり、それには当然 <code>#prop1</code> というプライベートプロパティが存在するので、<code>#prop1 in this</code> の結果は <code>true</code> になります。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  #prop1<span>;</span>\n  <span>foo</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> #prop1 <span>in</span> <span>this</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>console</span><span>.</span><span>log</span><span>(</span><span>new</span> <span>Foo</span><span>(</span><span>)</span><span>.</span><span>foo</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<h2>モチベーション</h2>\n<p>存在しないプライベートフィールドにアクセスすると、実行時エラーが発生します。</p>\n<p>その挙動と try / catch を組み合わせて、次のようにしてオブジェクトのクラスを判定できます。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  #brand<span>;</span>\n  <span>static</span> <span>isFoo</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      obj<span>.</span><span>#brand</span><span>;</span>\n      <span>return</span> <span>true</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>{</span>\n      <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre></div>\n<p><code>obj.#brand</code> にアクセスしたとき、<code>obj</code> が Foo のインスタンスでない場合、実行時エラーが発生し <code>catch</code> に入り <code>false</code> が返されます。\nこのようにして、あるオブジェクトが<code>Foo</code>のインスタンスであるかを検証するスタティックメソッドを作れます。</p>\n<p>ですが、このパターンは冗長です。<code>in</code> 演算子を使えばもっと短く書けます。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  #brand<span>;</span>\n  <span>static</span> <span>isFoo</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n    <span>return</span> #brand <span>in</span> obj<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre></div>\n<p>これが、このプロポーザルの主なモチベーションです。</p>\n<p><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/instanceof\"><code>instanceof</code> 演算子</a>も基本的にはこの目的のために使えます。しかし <code>instanceof</code> 演算子はプロトタイプに依存するので、プロトタイプを書き換えることでその挙動を変更できます。</p>\n<p>次の例では、 <code>obj</code> は <code>Foo</code> のインスタンスではありませんが、後からプロトタイプを書き換えているので <code>obj instanceof Foo</code> は <code>true</code> になっています。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span><span>}</span>\n<span>const</span> foo <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>Object</span><span>.</span><span>setPrototypeOf</span><span>(</span>obj<span>,</span> foo<span>)</span><span>;</span>\n<span>console</span><span>.</span><span>log</span><span>(</span>obj <span>instanceof</span> <span>Foo</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<p>また、<a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance\">Symbol.hasInstance</a> を使って <code>instanceof</code> の挙動を変更することも可能です。</p>\n<p>なので、より安全にオブジェクトのもとになったクラスを検証したい場合は <code>in</code> 演算子を使うと良いでしょう。</p>\n<h2>参考リンク</h2>\n<ul>\n<li><a href=\"https://tc39.es/ecma262/#prod-RelationalExpression\">https://tc39.es/ecma262/#prod-RelationalExpression</a></li>\n<li><a href=\"https://tc39.es/ecma262/#prod-PrivateIdentifier\">https://tc39.es/ecma262/#prod-PrivateIdentifier</a></li>\n<li><a href=\"https://github.com/tc39/proposal-private-fields-in-in\">https://github.com/tc39/proposal-private-fields-in-in</a></li>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/in\">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/in</a></li>\n</ul>\n","metaData":{"title":"ES2022 と TypeScript 4.5 に入るプライベートフィールドのための in 演算子について","author":"sosukesuzuki","createdAt":"2021-11-11","summary":"ES2022 と TypeScript 4.5 に入る現在 Stage 4 の提案 Ergonomic brand checks for Private Fields についての解説です。","tags":["ECMAScript","TypeScript"],"updatedAt":"2021-11-11"}},{"slug":"tc39-meeting-2021-10","content":"<div><pre><code>※ 旧タイトル: TC39 meeting 86th の概要とステージの移動</code></pre></div>\n<p>TC39 の 86 回目のミーティングが 10/25 ~ 10/28 に開催されました。\nこのミーティングで議題に上がった提案と、そのステージの移動について紹介します。</p>\n<ul>\n<li><a href=\"https://github.com/tc39/agendas/blob/master/2021/10.md\">agendas/10.md at master · tc39/agendas</a></li>\n<li><a href=\"https://github.com/babel/proposals/issues/77\">Oct 2021 · Issue #77 · babel/proposals</a></li>\n</ul>\n<h2>for Stage 4</h2>\n<h3><a href=\"https://github.com/tc39/proposal-error-cause\">Error Cause</a></h3>\n<p><strong>Stage 4 になりました。ECMAScript 2022 に入ります</strong></p>\n<p>Error Cause は、<code>Error</code> コンストラクタの第 2 引数に <code>cause</code> という値で原因となったエラーを渡すことができるようにする提案です。\nキャッチする側では、<code>error.cause</code> で、そのエラーを取得できます。</p>\n<p>例を示します。</p>\n<p><code>doUploadJob</code> 関数は <code>fetch</code> を実行して失敗したときに新しいエラーをスローします。そのエラーの第 2 引数に <code>{ cause: err }</code> というオブジェクトを渡しています。</p>\n<div><pre><code><span>async</span> <span>function</span> <span>doUploadJob</span><span>(</span><span>)</span> <span>{</span>\n  <span>await</span> <span>fetch</span><span>(</span><span>\"https://example.com/upload\"</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>\"Upload job result failed\"</span><span>,</span> <span>{</span> <span>cause</span><span>:</span> err <span>}</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>try</span> <span>{</span>\n  <span>await</span> <span>doJob</span><span>(</span><span>)</span><span>;</span>\n<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>\"Caused by\"</span><span>,</span> e<span>.</span><span>cause</span><span>)</span><span>;</span>\n<span>}</span>\n<span>// Error: Upload job result failed</span>\n<span>// Caused by TypeError: Failed to fetch</span>\n</code></pre></div>\n<p><code>doUploadJob</code> がスローしているエラーメッセージは <code>\"Upload job result failed\"</code> ですが、その原因となったエラーを <code>cause</code> として渡すことで、キャッチする側でどのエラーが原因で失敗したのかを取得できます。</p>\n<p>この例では、<code>doUploadJob</code> が失敗した原因が <code>TypeError: Failed to fetch</code> であったことがわかります。</p>\n<h2>for Stage 3</h2>\n<p>今回は、for Stage 3 の提案はありませんでした。</p>\n<h2>for Stage 2</h2>\n<h3><a href=\"https://github.com/tc39/proposal-array-grouping\">Array Grouping</a></h3>\n<p><strong>Stage 2 になりました</strong></p>\n<p>Array Grouping は、<code>Array</code> に <code>groupBy</code> というインスタンスメソッドを追加する提案です。</p>\n<p>ユースケースは<a href=\"https://lodash.com/docs/4.17.15#groupBy\">Lodash の <code>groupBy</code></a> と同様です。</p>\n<div><pre><code><span>const</span> array <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>;</span>\narray<span>.</span><span>groupBy</span><span>(</span><span>(</span><span>i</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> i <span>%</span> <span>2</span> <span>===</span> <span>0</span> <span>?</span> <span>\"even\"</span> <span>:</span> <span>\"odd\"</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// =>  { odd: [1, 3, 5], even: [2, 4] }</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/tc39/proposal-partial-application\">Partial Application</a></h3>\n<p><strong>Stage 2 になりませんでした</strong></p>\n<p>Partial Application は、関数の部分適用のための構文を導入します。</p>\n<p>例を示します。</p>\n<p><code>add</code> は 2 つの引数を受け取り、その 2 つを足し合わせて返すだけの単純な関数です。\nそして、Partial Application を使って <code>addOne</code> という新しい関数を作っています。<code>addOne</code> は、1 つの引数を受け取り、それに<code>1</code>を足して返す関数です。\nつまり、既存の関数の一部の引数だけ渡して、残りの引数を受け取るような関数を作ることができます。</p>\n<div><pre><code><span>const</span> <span>add</span> <span>=</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>=></span> x <span>+</span> y<span>;</span>\n<span>const</span> addOne <span>=</span> add<span>~</span><span>(</span><span>1</span><span>,</span> <span>?</span><span>)</span><span>;</span>\n<span>addOne</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 3</span>\n</code></pre></div>\n<p>現在の JavaScript で表現すると、次のようになります。</p>\n<div><pre><code><span>const</span> <span>add</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=></span> <span>(</span><span>y</span><span>)</span> <span>=></span> x <span>+</span> y<span>;</span>\n<span>const</span> addOne <span>=</span> <span>add</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>addOne</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 3</span>\n</code></pre></div>\n<p>Haskell のような関数型プログラミング言語では標準で備わっている機能です。</p>\n<h2>for Stage 1</h2>\n<h3><a href=\"https://github.com/bathos/proposal-string-cooked\"><code>String.cooked</code></a></h3>\n<p><strong>Stage 1 になりました</strong></p>\n<p><code>String.cooked</code> は <code>String</code> に新しいスタティックメソッド <code>cooked</code> を追加する提案です。\n<code>String.cooked</code> は <a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw</code></a> と逆のことをします。</p>\n<div><pre><code><span>String</span><span>.</span><span>raw</span><span><span>`</span><span>mmm ... \\u0064elicious cooked string</span><span>`</span></span><span>;</span>\n<span>// mmm ... \\u0064elicious cooked string</span>\n<span>String</span><span>.</span><span>cooked</span><span><span>`</span><span>mmm ... \\u0064elicious cooked string</span><span>`</span></span><span>;</span>\n<span>// \"mmm ... delicious cooked string\"</span>\n</code></pre></div>\n<p>つまり、通常のテンプレートリテラルとおなじ挙動です。</p>\n<div><pre><code><span><span>`</span><span>mmm ... \\u0064elicious cooked string</span><span>`</span></span><span>;</span>\n<span>// \"mmm ... delicious cooked string\"</span>\n</code></pre></div>\n<p>この機能がタグ付きテンプレートリテラルとして存在することで、これを用いて新しいタグ付きテンプレートリテラルを作るときに役にたちます。</p>\n<div><pre><code><span>function</span> <span>myTag</span><span>(</span><span>strings<span>,</span> <span>...</span>values</span><span>)</span> <span>{</span>\n  <span>return</span> <span>String</span><span>.</span><span>cooked</span><span>(</span>strings<span>,</span> <span>...</span>values<span>.</span><span>map</span><span>(</span><span>value</span> <span>=></span> <span>String</span><span>(</span>value<span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span>\n<span>}</span>\n\nmyTag<span><span>`</span><span>hello </span><span><span>${</span><span>'world'</span><span>}</span></span><span>`</span></span> <span>// \"hello WORLD\"</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/jridgewell/proposal-destructuring-private\">Destructure Private Fields</a></h3>\n<p><strong>Stage 1 を飛ばして、Stage 2 になりました</strong></p>\n<p>Destructure Private Fields は、プライベートフィールドの分割代入のための構文を導入します。</p>\n<p><code>#</code> からはじまる識別子は通常であれば存在できないので、別の名前にリネームする必要があります。次の例では <code>this.#x</code> を <code>x</code> という名前にリネームしています。</p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>\n  #x <span>=</span> <span>1</span><span>;</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span><span>#x</span><span>)</span><span>;</span> <span>// => 1</span>\n    <span>const</span> <span>{</span> #x<span>:</span> x <span>}</span> <span>=</span> <span>this</span><span>;</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span> <span>// => 1</span>\n  <span>}</span>\n<span>}</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/js-choi/proposal-bind-this\">Bind-this operator</a></h3>\n<p><strong>Stage 1 になりました</strong></p>\n<p>Bind this operator は、<a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">Function.prototype.bind</a> と同様の方法で関数をバインドするための二項演算子を導入する提案です。</p>\n<p>以前から存在する Stage 0 の <a href=\"https://github.com/tc39/proposal-bind-operator\">Bind Operator</a> の後継であり、Stage 1 の <a href=\"https://github.com/tc39/proposal-extensions\">Extensions</a> の競合です。</p>\n<div><pre><code><span>Object</span><span>.</span><span>prototype</span><span>.</span><span>hasOwnProperty</span><span>.</span><span>call</span><span>(</span><span>{</span> <span>foo</span><span>:</span> <span>\"foo\"</span> <span>}</span><span>,</span> <span>\"foo\"</span><span>)</span><span>;</span> <span>// true</span>\n<span>(</span><span>{</span> <span>foo</span><span>:</span> <span>\"foo\"</span> <span>}</span><span>:</span><span>:</span><span>Object</span><span>.</span><span>prototype</span><span>.</span><span>hasOwnProperty</span><span>(</span><span>\"foo\"</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/js-choi/proposal-function-helpers\">Function helpers</a></h3>\n<p><strong>Stage 1 になりませんでした。この提案に含まれる関数は個別の提案として再度提出されるかもしれません。</strong></p>\n<p>Function helpers は、<code>Function</code> のスタティックメソッドとして便利なヘルパー関数を追加する提案です。</p>\n<p><code>Function.flow</code> は引数に与えられた関数を合成した新しい関数を返します。</p>\n<div><pre><code><span>const</span> f <span>=</span> <span>Function</span><span>.</span><span>flow</span><span>(</span>f0<span>,</span> f1<span>,</span> f2<span>)</span><span>;</span>\n<span>f</span><span>(</span><span>5</span><span>,</span> <span>7</span><span>)</span><span>;</span> <span>// f2(f1(f0(5, 7))).</span>\n</code></pre></div>\n<p><code>Function.pipe</code> は第 1 引数の値を、それ移行の引数として渡された関数を合成した関数に渡した結果を返します。</p>\n<div><pre><code><span>Function</span><span>.</span><span>pipe</span><span>(</span><span>5</span><span>,</span> f0<span>,</span> f1<span>,</span> f2<span>)</span><span>;</span> <span>// f2(f1(f0(5))).</span>\n</code></pre></div>\n<p><code>Function.constant</code> は、第 1 引数として渡された値を返し続ける関数を返します。</p>\n<div><pre><code><span>const</span> f <span>=</span> <span>Function</span><span>.</span><span>constant</span><span>(</span><span>3</span><span>)</span><span>;</span>\n<span>f</span><span>(</span><span>\"fooo\"</span><span>)</span><span>;</span> <span>// 3</span>\n<span>f</span><span>(</span><span>3009</span><span>,</span> <span>33</span><span>,</span> <span>44</span><span>)</span><span>;</span> <span>// 3</span>\n<span>f</span><span>(</span><span>{</span> <span>foo</span><span>:</span> <span>\"foo\"</span> <span>}</span><span>)</span><span>;</span> <span>// 3</span>\n</code></pre></div>\n<p><code>Function.identifiy</code> は、第 1 引数に与えられた値をそのまま返します。</p>\n<div><pre><code><span>Function</span><span>.</span><span>identity</span><span>(</span><span>3</span><span>)</span><span>;</span> <span>// 3</span>\n<span>Function</span><span>.</span><span>identity</span><span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span><span>;</span> <span>// 4</span>\n</code></pre></div>\n<p><code>Function.tap</code> はコールバック関数を引数として受け取り、関数を返します。\n<code>Function.tape</code> が返した関数に引数を渡すと、それをコールバック関数に渡して実行し、その上でその引数をそのまま返します。\n言葉で説明すると難しいですが、例を見れば簡単だと思います。</p>\n<div><pre><code><span>const</span> f <span>=</span> <span>Function</span><span>.</span><span>tap</span><span>(</span><span>console</span><span>.</span><span>log</span><span>)</span><span>;</span>\n<span>f</span><span>(</span><span>5</span><span>)</span><span>;</span> <span>// 5 を出力して、5 を返す</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/lucacasonato/proposal-evaluator-attributes\">Evaluator Attributes</a></h3>\n<p><strong>Stage 1 になりました</strong></p>\n<p>Evaluator Attributes は、インポートされたモジュールの評価方法を処理系に伝えるための構文を導入します。</p>\n<p>例にある通り、提案された目的は WebAssembly のモジュールを JavaScript の Import 文で読み込むためです。しかし、提案の仕様としては WebAssembly には限られていません。</p>\n<div><pre><code><span>import</span> <span>mod</span> <span>from</span> <span>\"./foo.wasm\"</span> <span>as</span> <span>\"wasm-module\"</span><span>;</span>\nmod <span>instanceof</span> <span>WebAssembly<span>.</span>Module</span><span>;</span> <span>// true</span>\n</code></pre></div>\n<p>現在 Stage 3 の <a href=\"https://github.com/tc39/proposal-import-assertions\">Import Assertions</a> に似ていますが、Import Assertions はモジュールの評価方法に影響を与えることはできません。</p>\n<h3>RegExp Features</h3>\n<p>前回のミーティングで提案された<a href=\"https://github.com/rbuckton/proposal-regexp-features\">RegExp Features</a>が機能ごとに別々の提案に分割されました。</p>\n<h4><a href=\"https://github.com/rbuckton/proposal-regexp-modifiers\">RegExp Modifiers</a></h4>\n<p><strong>Stage 1 になりました</strong></p>\n<h4><a href=\"https://github.com/rbuckton/proposal-regexp-x-mode\">RegExp Extended Mode and Comments</a></h4>\n<p><strong>Stage 1 になりました</strong></p>\n<h4><a href=\"https://github.com/rbuckton/proposal-regexp-atomic-operators\">RegExp Atomic Operators</a></h4>\n<p><strong>Stage 1 になりませんでした</strong></p>\n<h4><a href=\"https://github.com/rbuckton/proposal-regexp-r-escape\">RegExp <code>\\R</code> Escape</a></h4>\n<p><strong>Stage 1 になりました</strong></p>\n<h4><a href=\"https://github.com/rbuckton/proposal-regexp-buffer-boundaries\">RegExp Buffer Boundaries</a></h4>\n<p><strong>Stage 1 になりました</strong></p>\n<h3>Updates</h3>\n<p>ステージの移動はないものの、アップデートがあった提案です。</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-change-array-by-copy\">Change Array by Copy</a></li>\n<li><a href=\"https://github.com/tc39/proposal-json-parse-with-source\">JSON.parse sourct text access</a></li>\n<li><a href=\"https://github.com/tc39/proposal-record-tuple/\">Records &#x26; Tuples</a></li>\n<li><a href=\"https://github.com/tc39/proposal-explicit-resource-management\">Explicit Resource Management</a></li>\n<li><a href=\"https://github.com/tc39/proposal-js-module-blocks\">JS Module Blocks</a></li>\n<li><a href=\"https://github.com/js-choi/proposal-array-from-async\">Array.fromAsync</a></li>\n</ul>\n<h2>その他</h2>\n<p>提案ではなく、仕様書の変更として扱われているものです。</p>\n<h3><a href=\"https://github.com/tc39/ecma262/pull/1321\">Extending null</a></h3>\n<p><strong>合意は得られませんでした</strong></p>\n<div><pre><code><span>class</span> <span>Foo</span> <span>extends</span> <span>null</span> <span>{</span><span>}</span>\n</code></pre></div>\n","metaData":{"title":"ECMAScriptの最新動向 2021年11月版","author":"sosukesuzuki","editor":"nakajmg","createdAt":"2021-11-02","summary":"2021年10月25日~28日に開催された TC39 meeting 86th の内容を紹介します","tags":["TC39","ECMAScript"],"updatedAt":"2021-11-02"}},{"slug":"first-post","content":"<p>こんにちは、サイボウズフロントエンドエキスパートチームの<a href=\"https://twitter.com/__sosukesuzuki\">@__sosukesuzuki</a>です。</p>\n<p>サイボウズには<a href=\"https://blog.cybozu.io/\">Cybozu Inside Out</a>という技術ブログがあります。\nそれとは別に、この度フロントエンドエキスパートチームとしてウェブサイトを開設することにしました。</p>\n<p>この記事では、このウェブサイトを開設することになった経緯と目的、使用した技術について説明します。</p>\n<h2>経緯</h2>\n<p>フロントエンドエキスパートチームでは、チームでのコミュニケーションの促進を主な目的としてハッカソンを開催することがあります。\n(チームでのハッカソンについては<a href=\"https://blog.cybozu.io/entry/2021/02/25/133039\">Cybozu Inside Out に投稿されている記事</a>をご覧ください)</p>\n<p>そのようなハッカソンで、フリーテーマの回がありました。\nそこで、<a href=\"https://twitter.com/__sakito__\">Sakito</a>さんと<a href=\"https://twitter.com/b4h0_c4t\">BaHo</a>さんと<a href=\"https://twitter.com/__sosukesuzuki\">sosukesuzuki</a>(私)のチームでは、フロントエンドエキスパートチームのウェブサイトを作ってみることにしました。</p>\n<p>ハッカソンの期間内に完成することはありませんでしたが、チームとしてウェブサイトを持っていた方が良いということで合意が得られたので、ハッカソン終了後も開発を継続することにしました。</p>\n<h2>目的</h2>\n<p>フロントエンドエキスパートチームの活動を多くの人に知ってもらうためです。</p>\n<p>フロントエンドエキスパートチームでは、日頃から様々なフロントエンド技術の啓蒙活動を行っています。\nそれらの多くはクローズドな場所で行われています。しかし基本的にその内容はサイボウズ特有のものではなく、一般的に有用な情報です。</p>\n<p>そこで、フロントエンドエキスパートチームとしてウェブサイトを開設し、公開できる有用な情報は公開することにしました。</p>\n<p>このウェブサイトを通して、フロントエンドエキスパートチームに興味を持ってくれたら嬉しいです。</p>\n<h2>技術</h2>\n<p>次の要件を満たす技術として、<a href=\"https://github.com/vercel/next.js\">Next.js</a> を採用しました。</p>\n<ul>\n<li>環境構築が簡単である\n<ul>\n<li>もともとハッカソンで開発していたので、環境構築に多くの時間を割けないという事情がありました。</li>\n</ul>\n</li>\n<li>SSG の機能を備えている\n<ul>\n<li>すべてのコンテンツは静的なものと決まっていたので、SSG ができると嬉しい</li>\n</ul>\n</li>\n<li>TypeScript との相性が良い</li>\n</ul>\n<p>記事は Markdown として管理して Next.js の <code>getStaticProps</code> のタイミングで <a href=\"https://github.com/remarkjs/remark\">remark</a> を使って HTML に変換しています。</p>\n<p>また、ブログの機能を持つので、feed の生成と記事ごとの OGP 画像の生成をのためのスクリプトをそれぞれ用意しました。feed 生成スクリプトは、記事データの Markdown からメタデータを取得し、XML ファイルを書き出します。\nOGP 画像生成スクリプトは、記事データの Markdown からタイトルを取得し、<a href=\"https://github.com/puppeteer/puppeteer\">Puppeteer</a> で画像を生成します。</p>\n<p>ホスティングには GitHub Pages を使っています。GitHub で管理している HTML をホストする先としてはやはり楽です。</p>\n<p>実装はすべて <a href=\"https://github.com/cybozu/frontend-expert\">https://github.com/cybozu/frontend-expert</a> で公開しています。</p>\n<h2>おわりに</h2>\n<p>これから、不定期ではありますが、当サイトにてフロントエンドに関連する情報を発信していく予定です。ぜひ読んでみてくださいね。</p>\n","metaData":{"title":"サイボウズフロントエンドエキスパートチームのウェブサイトを作りました","author":"sosukesuzuki","createdAt":"2021-10-14","summary":"このウェブサイトを開設することになった経緯と目的、使用した技術について説明します。","tags":["Announcement"],"updatedAt":"2021-10-14"}}]},"__N_SSG":true}