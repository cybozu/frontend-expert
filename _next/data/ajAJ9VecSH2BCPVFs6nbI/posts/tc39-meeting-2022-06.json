{"pageProps":{"post":{"slug":"tc39-meeting-2022-06","content":"<p>この記事では2022年06月06日~09日に開催された TC39 meeting 90th で議題に上がったプロポーザルを紹介します。</p>\n<h3>For Stage 4</h3>\n<h3><a href=\"https://github.com/tc39/proposal-array-find-from-last/\"><code>findLast</code> / <code>findLastIndex</code></a></h3>\n<p><strong>Stage 4 に到達しました</strong></p>\n<p><code>findLast</code> と <code>findLastIndex</code> は、<code>Array.prototype.find</code> と <code>Array.prototype.findIndex</code> の逆から走査するバージョンです。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">prop1</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">prop2</span><span class=\"token operator\">:</span> <span class=\"token string\">\"foo\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">prop1</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">props2</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> obj1 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">element</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> element<span class=\"token punctuation\">.</span><span class=\"token property-access\">prop1</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">.</span><span class=\"token property-access\">prop2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"foo\"</span>\n<span class=\"token keyword\">const</span> obj2 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">findLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">element</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> element<span class=\"token punctuation\">.</span><span class=\"token property-access\">prop1</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">.</span><span class=\"token property-access\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"bar\"</span>\n</code></pre></div>\n<p>このミーティングの時点で V8、JavaScriptCore(フラグ付き)、ChakraCore(フラグ付き) にはすでに実装されており、<a href=\"https://spidermonkey.dev/blog/2022/06/30/newsletter-firefox-102-103.html\">SpiderMonkey でも後日実装されたようです</a>。</p>\n<p>(余談ですが筆者は、このプロポーザルのスライド資料を読んで ChakraCore の開発が未だに継続されていることと TC39 プロセスにおける実装の一つとして数えられていることをはじめて知りました。)</p>\n<h2>For Stage 3</h2>\n<h3><a href=\"https://github.com/tc39/proposal-symbols-as-weakmap-keys\">Symbols as WeakMap keys</a></h3>\n<p><strong>Stage 3 に到達しました</strong></p>\n<p>Symbols as WeakMap keys は WeakMap のキーとして Symbol を使えるようにするプロポーザルです。</p>\n<p>提案の概要については</p>\n<p><div class=\"hatena-link\"><iframe class=\"hatena-link-frame\" src=\"https://hatenablog-parts.com/embed?url=https://sosukesuzuki.dev/posts/symbols-as-weakmap-keys\" style=\"border: none;\"></iframe></div></p>\n<p>を見てください。</p>\n<p>これまでの流れについては</p>\n<p><div class=\"hatena-link\"><iframe class=\"hatena-link-frame\" src=\"https://hatenablog-parts.com/embed?url=https://cybozu.github.io/frontend-expert/posts/tc39-meeting-2022-01\" style=\"border: none;\"></iframe></div></p>\n<p>を見てください。</p>\n<p>Symbols as WeakMap keys が一見シンプルながらこれまで Stage 2 のままだったのは、グローバルシンボルレジストリに登録された symbol や well-known symbols などのいわゆる eternal symbol を WeakMap のキーとして許容するかどうか、という論点のためでした。</p>\n<p>スライド( <a href=\"http://www.rricard.me/serve/tc39-jun2022-symbols-as-wm-keys.pdf\">http://www.rricard.me/serve/tc39-jun2022-symbols-as-wm-keys.pdf</a> ) 上では次のように書かれています。</p>\n<ul>\n<li>通常の Symbol コンストラクタで作られる unique symbols は WeakMap のキーとして許容する</li>\n<li><code>Symbol.for(\"...\")</code> で作られるグローバルシンボルレジストリに登録された registered symbols は WeakMap のキーとして許容しない</li>\n<li>well-known symbols は WeakMap のキーとして許容する</li>\n</ul>\n<p>実際 <a href=\"https://tc39.es/proposal-symbols-as-weakmap-keys/\">https://tc39.es/proposal-symbols-as-weakmap-keys/</a> を見る限り WeakMap のキーとして妥当かどうかを判断するために使われている abstract operation <a href=\"https://tc39.es/proposal-symbols-as-weakmap-keys/#sec-canbeheldweakly-abstract-operation\"><code>CanBeHeldWeakly</code></a> では registerd symbols を許容していないようです。</p>\n<h3><a href=\"https://github.com/tc39/proposal-regexp-modifiers\">RegExp Modifiers</a></h3>\n<p><strong>Stage 3 に到達しました</strong></p>\n<p>RegExp Modifiers は正規表現パターンの中でのフラグの変更を可能にするプロポーザルです。</p>\n<p>概要については 2021 年 12 月の記事を見てください。</p>\n<p><div class=\"hatena-link\"><iframe class=\"hatena-link-frame\" src=\"https://hatenablog-parts.com/embed?url=https://cybozu.github.io/frontend-expert/posts/tc39-meeting-2021-12\" style=\"border: none;\"></iframe></div></p>\n<h3><a href=\"https://github.com/tc39/proposal-json-parse-with-source\"><code>JSON.parse</code> source text access</a></h3>\n<p><strong>仕様のテキストの修正を待って条件付き Stage 3 にるようです</strong></p>\n<p><code>JSON.parse</code> source text access は、<code>JSON.parse</code> の第２引数として渡すことができる関数(reviver)の中でもとのテキストにアクセスできるようにするためのプロポーザルです。</p>\n<p>reviver ではパースした JSON のそれぞれのメンバーのキーとバリューにアクセスし、結果のオブジェクトを返す前になんらかの変換を施すことができます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token known-class-name class-name\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">parse</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">{ \"foo\": 3 }</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">key<span class=\"token punctuation\">,</span> value</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> value <span class=\"token operator\">===</span> <span class=\"token string\">\"number\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">return</span> value <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword control-flow\">return</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// { \"foo\": 5 }</span>\n</code></pre></div>\n<p>この reviver の引数としてキーとバリューが渡ってきた時点ですでにもとのテキストには存在する情報が失われていることがあります。</p>\n<p>たとえば <code>{ \"key\": 999999999999999999 }</code> という JSON を <code>JSON.parse</code> でパースするときに、reviver で受け取った引数をそのまま出力する例を考えてみましょう。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token known-class-name class-name\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">parse</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">{ \"key\": 999999999999999999 }</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">key<span class=\"token punctuation\">,</span> value</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword control-flow\">return</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1000000000000000000</span>\n</code></pre></div>\n<p>もとの値は <code>999999999999999999</code> なのに実際に出力された値は <code>1000000000000000000</code> になっています。つまり、reviver の引数として受け取った時点でですでに <code>999999999999999999</code> ではなく <code>1000000000000000000</code> になってしまっています。</p>\n<p>なので、渡されたメンバーのバリューが <code>999999999999999999</code> なのかそれとも <code>1000000000000000000</code> なのか、reviver 側からは判断ができません。</p>\n<p>これでは困るので <code>JSON.parse</code> source text access では、次のようなインターフェースでもとのソーステキストにアクセスできます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token known-class-name class-name\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">parse</span><span class=\"token punctuation\">(</span>\n  <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">{ \"key\": 999999999999999999 }</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token parameter\">key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> source <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n  　　<span class=\"token comment\">// ここで source には '999999999999999999' という文字列が入ってる</span>\n    <span class=\"token spread operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h2>For Stage 2</h2>\n<h3><a href=\"https://github.com/tc39/proposal-string-dedent\"><code>String.dedent</code></a></h3>\n<p><strong>Stage 2 に到達しました</strong></p>\n<p><code>String.dedent</code> はテンプレートリテラルの内部のインデントを適切に除去するためのタグ付きテンプレートリテラルを追加するプロポーザルです。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"></span>\n<span class=\"token string\">      create table student(</span>\n<span class=\"token string\">        id int primary key,</span>\n<span class=\"token string\">        name text</span>\n<span class=\"token string\">      )</span>\n<span class=\"token string\">    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>このようなコードを書くと、実際に出力される文字列には、通常プログラマーが期待するものとは異なるスペースが含まれることになります。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*</span>\n<span class=\"token comment\"></span>\n<span class=\"token comment\">      create table student(</span>\n<span class=\"token comment\">        id int primary key,</span>\n<span class=\"token comment\">        name text</span>\n<span class=\"token comment\">      )</span>\n<span class=\"token comment\">    </span>\n<span class=\"token comment\">*/</span>\n</code></pre></div>\n<p>こういうときのために適切にインデントを取り除いてくれるのが <code>String.dedent</code> です。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span><span class=\"token known-class-name class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">dedent</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"></span>\n<span class=\"token string\">      create table student(</span>\n<span class=\"token string\">        id int primary key,</span>\n<span class=\"token string\">        name text</span>\n<span class=\"token string\">      )</span>\n<span class=\"token string\">    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/*</span>\n<span class=\"token comment\">create table student(</span>\n<span class=\"token comment\">  id int primary key,</span>\n<span class=\"token comment\">  name text</span>\n<span class=\"token comment\">)</span>\n<span class=\"token comment\">*/</span>     \n</code></pre></div>\n<h3><a href=\"https://github.com/tc39/proposal-grouped-and-auto-accessors\">Grouped and Auto-Accessors</a></h3>\n<p><strong>Stage 2 に到達しませんでした</strong></p>\n<p>Grouped and Auto-Accessors はクラスのアクセサを定義する新しい方法を導入するプロポーザルです。</p>\n<p>まず Grouped は次のようにして一つのプロパティのアクセサをまとめて定義できます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span> <span class=\"token punctuation\">{</span>\n  accessor x <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token spread operator\">...</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token spread operator\">...</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  accessor x <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token spread operator\">...</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token spread operator\">...</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>そして Auto-Accessors は Grouped に対するシンタックスシュガーのようなものです。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span> <span class=\"token punctuation\">{</span>\n  accessor a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `accessor a { get; set; } = 1` と同じ</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>プロポーザルに README では様々なパターンが紹介されているので興味がある人はそちらを参照してください。</p>\n<h2>For Stage 1</h2>\n<h3><a href=\"https://github.com/bakkot/proposal-duplicate-named-capturing-groups\">Duplicate named capture groups</a></h3>\n<p><strong>Stage 2 に到達しました</strong></p>\n<p>この提案はもともと Stage 0 でしたが、アジェンダ上の議題は</p>\n<blockquote>\n<p>Duplicate named capture groups for stage 1, 2, or 3 reaches Stage 2</p>\n</blockquote>\n<p>でした。そして実際に Stage 1 をスキップして Stage 2 に到達しました。</p>\n<p>Duplicate named capture groups は正規表現の中で同名の名前付きグループを複数記述可能にするためのプロポーザルです。</p>\n<p>次のコードを見てください。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\">str<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\"><span class=\"token group punctuation\">(?&#x3C;<span class=\"token group-name variable\">year</span>></span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token range\">0<span class=\"token range-punctuation operator\">-</span>9</span><span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">{4}</span><span class=\"token group punctuation\">)</span>-<span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token range\">0<span class=\"token range-punctuation operator\">-</span>9</span><span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">{2}</span><span class=\"token alternation keyword\">|</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token range\">0<span class=\"token range-punctuation operator\">-</span>9</span><span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">{2}</span>-<span class=\"token group punctuation\">(?&#x3C;<span class=\"token group-name variable\">year</span>></span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token range\">0<span class=\"token range-punctuation operator\">-</span>9</span><span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">{4}</span><span class=\"token group punctuation\">)</span></span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>これは yyyy-MM もしくは MM-yyyy の形をした文字列のマッチする正規表現ですが、現在の ECMAScript としてはインバリッドです。なぜなら同じ正規表現の中で同名の名前付きキャプチャグループが複数存在するからです。</p>\n<p>このようなケースでは、同じ正規表現の中に同名の名前付きキャプチャグループを複数記述できると便利です。</p>\n<h3><a href=\"https://github.com/hax/proposal-this-parameter\"><code>this</code> parameter</a></h3>\n<p><strong>Stage 1 に到達しませんでした</strong></p>\n<p><code>this</code> parameter は、TypeScript の <code>this</code> parameter のような構文を JavaScript に導入するためのプロポーザルです。</p>\n<p>次のようなモチベーションがあるようです。</p>\n<ul>\n<li>様々なツールチェインのために TypeScript の <code>this</code> parameter を標準化すること</li>\n<li>JavaScript と TypeScript の間のギャップを埋めることで初学者にとって易しくなるため</li>\n<li><a href=\"https://github.com/tc39/proposal-type-annotations\">Type Annotations</a> によってもたらされる負担をへらすため</li>\n<li>メソッドの構文を提供するため</li>\n</ul>\n<p>現在 Stage 1 の <a href=\"https://github.com/tc39/proposal-call-this\">call-this</a> においては、this を明示できるほうがわかりやすいのかもしれません。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">toHex</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">this</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token number\">42</span><span class=\"token operator\">~</span><span class=\"token operator\">></span><span class=\"token function\">toHex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<h3><a href=\"https://github.com/rbuckton/proposal-regexp-atomic-operators\">RegExp Atomic Operators</a></h3>\n<p><strong>Stage 1 に到達しました</strong></p>\n<p>RegExp Atomic Operators はバックトラックを制御するための新しい構文を正規表現に追加するプロポーザルです。</p>\n<p>たとえば <code>/a(bc|b)c/</code> という正規表現は <code>\"abcc\"</code> にも <code>\"abc\"</code> にもマッチします。\n<code>\"abcc\"</code> のときは単純で、まず先頭の <code>a</code> がマッチし、次に <code>(bc|b)</code> の <code>bc</code> にマッチして、最後に <code>c</code> がマッチします。\n一方で <code>\"abc\"</code> のときはやや複雑です。まず先頭の <code>a</code> がマッチし、次に <code>(bc|b)</code> の <code>bc</code> にマッチしますが、そうすると最後の <code>c</code> にはマッチできません。そこで <code>(bc|b)</code> までもどります。前回のマッチングにおいて <code>bc</code> ではマッチできなかったので、もう一つの選択肢である <code>b</code> にマッチさせます。そして最後の <code>c</code> にマッチします。</p>\n<p>このような後続のパターンがマッチしない場合に一つ前のパターンに戻ってマッチを試みることをバックトラックといいます。RegExp Atomic Operators はこのようなバックトラックを制御するための構文を追加します。</p>\n<p>たとえば前述の <code>/a(bc|b)c</code> というパターンでバックトラックが発生しないように Atomic Operators を使って書くと <code>/a(?>(bc|b))c</code> になります。このパターンでは <code>\"abcc\"</code> にはマッチしますが、<code>(bc|c)</code> へのバックトラックが発生しないため <code>\"abc\"</code> にはマッチしません。</p>\n<p>他にもいくつかの新しい構文があるみたいなので興味がある人はプロポーザルの README かスペックテキストを参照してください。</p>\n<h2>Updates</h2>\n<p>ステージの移動はないものの更新が紹介された提案を列挙します。ここでは詳細については説明しませんがスライドや関連するIssueへのリンクを貼ったので興味のある人は参照してください。</p>\n<h3><a href=\"https://github.com/tc39/proposal-array-grouping\">Array Grouping</a></h3>\n<p>Array Grouping は <a href=\"https://lodash.com/docs/4.17.15#groupBy\">Lodash の <code>groupBy</code></a> のように配列をグルーピングするメソッドを導入するプロポーザルです。</p>\n<p>今回の変更で <code>groupBy</code> と <code>groupByToMap</code> から <code>group</code> と <code>groupToMap</code> へとメソッドの名前が変更されました。</p>\n<p>詳細は該当の Pull Request( <a href=\"https://github.com/tc39/proposal-array-grouping/pull/39\">https://github.com/tc39/proposal-array-grouping/pull/39</a> )を見てください。</p>\n<h3><a href=\"https://github.com/tc39/proposal-decorators\">Decorators</a></h3>\n<ul>\n<li><a href=\"https://slides.com/pzuraq/decorators-normative-changes-2022-06\">https://slides.com/pzuraq/decorators-normative-changes-2022-06</a></li>\n</ul>\n<h3><a href=\"https://github.com/tc39/proposal-shadowrealm\">Shadow Realms</a></h3>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-shadowrealm/issues/365\">https://github.com/tc39/proposal-shadowrealm/issues/365</a></li>\n</ul>\n<h3><a href=\"https://tc39.es/proposal-temporal/\">Temporal</a></h3>\n<ul>\n<li><a href=\"http://ptomato.name/talks/tc39-2022-06/\">http://ptomato.name/talks/tc39-2022-06/</a></li>\n</ul>\n<h3><a href=\"https://github.com/tc39/proposal-function.sent\"><code>function.sent</code></a></h3>\n<ul>\n<li><a href=\"https://johnhax.net/2022/function-sent/slide#0\">https://johnhax.net/2022/function-sent/slide#0</a></li>\n</ul>\n<h3><a href=\"https://github.com/tc39/proposal-import-reflection\">Import Reflection</a></h3>\n<ul>\n<li><a href=\"https://docs.google.com/presentation/d/1y0MAo7ymIWzyyrU9o3oKLiHc4BtQwLtqlU4Z_8_XYjU/edit#slide=id.p\">https://docs.google.com/presentation/d/1y0MAo7ymIWzyyrU9o3oKLiHc4BtQwLtqlU4Z_8_XYjU/edit#slide=id.p</a></li>\n</ul>\n<h2>参考リンク</h2>\n<ul>\n<li>TC39\n<ul>\n<li><a href=\"https://github.com/tc39/agendas/blob/main/2022/06.md\">agendas/06.md at main · tc39/agendas</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/main/meetings/2022-06/jun-06.md\">notes/jun-06.md at main · tc39/notes</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/main/meetings/2022-06/jun-07.md\">notes/jun-07.md at main · tc39/notes</a></li>\n<li><a href=\"https://github.com/tc39/notes/blob/main/meetings/2022-06/jun-08.md\">notes/jun-08.md at main · tc39/notes</a></li>\n</ul>\n</li>\n<li>Babel\n<ul>\n<li><a href=\"https://github.com/babel/proposals/issues/82\">Jun 2022 · Issue #82 · babel/proposals</a></li>\n</ul>\n</li>\n<li>SpiderMonkey\n<ul>\n<li><a href=\"https://spidermonkey.dev/blog/2022/06/30/newsletter-firefox-102-103.html\">SpiderMonkey Newsletter (Firefox 102-103) | SpiderMonkey JavaScript/WebAssembly Engine</a></li>\n</ul>\n</li>\n</ul>\n","metaData":{"title":"ECMAScriptの最新動向 2022年06月版","author":"sosukesuzuki","createdAt":"2022-07-11","summary":"2022年06月06日~09日に開催された TC39 meeting 90th の内容を紹介します","tags":["TC39","ECMAScript"],"updatedAt":"2022-07-11"}}},"__N_SSG":true}